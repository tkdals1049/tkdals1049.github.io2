---
title: 정처기 실기   요약 정리
author: lee
date: 2022-05-08 20:17:00 +0800
categories: [자기계발, 자격증]
tags: [자격증]
---

<p data-ke-size="size14">◆ 애자일(Agile) 방법론 유형<span style="color: #ee2323;">(ex. 2020 02)</span> <br /><br />XP(eXtreme Programming): 의사소통 개선과 즉각적 피드백으로 스프트웨어 품질을 높이기 위한 방법론 <br /><br />XP 5가지 가치: 용기, 단순성, 의사소통, 피드백, 존중 <br />스크럼(Scrum): 매일 정해진 시간, 장소에서 짤은 시간의 개발을 하는 팀을 위한 프로젝트 관리 중심 방법론 <br />린(Lean): 도요타의 린 시스템 품질기법을 소프트웨어 개발 프로세스에 적용해서 낭비 욧를 제거하여 품질을 향상시킨 방법론 <br />Lean 7가지 가치: 낭비제거, 품질 내재화, 지식 창출, 늦은 확정, 빠른 인도, 사람 존중, 전체 최적화 <br /><br />XP의 주요 실천 방법<span style="color: #ee2323;">(ex. 2020 03)</span> <br /><br />- Pair Programming(짝 프로그래밍) <br /><br />- Test-Driven Development(테스트 주도 개발) <br /><br />- Whole Team(전체 팀) <br /><br />- Continuous Integration(계속적인 통합) <br /><br />- Design Improvement(디자인 개선) 또는 Refactoring(리팩토링)<br />- 소프트웨어를 보다 이해하기 쉽고, 수정하기 쉽도록 개선함 <br />- 결과의 변경없이 코드의 구조를 재조정하는 것으로 가독성을 높이고, 유지보수를 쉽게하기 위한 목적 <br />- 코드의 외부 행위는 바꾸지 않고 내부 구조를 개선시켜 소프트웨어를 보다 이해하기 쉽고, 수정하기 쉽도록 만드는 것 <br /><br />- Small Releases(소규모 릴리즈)</p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14">◆ 소프트웨어 아키텍처: 여러 가지 소프트웨어 구성요소과 그 구성요소가 가진 특성 중 외부에 드러나는 특성, 그리고 구성요소 간의 관계를 표현하는 시스템의 구조나 구조체</p>
<p data-ke-size="size14">◆ 소프트웨어 아키텍처 4+1 뷰<span style="color: #ee2323;"><b>(유논프구배)</b></span>: 고객의 요규사항을 정리해 놓은 시나리오를 4개의 관점에서 바라보는 소프트웨어적인 접근 방법</p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>유스케이스 뷰<span style="color: #666666;">(Usecase View)</span>: 유스케이스 또는 아키텍처를 도출하고 설계하며 다른 뷰를 검증하는데 사용되는 뷰</li>
<li>논리 뷰<span style="color: #666666;">(Logical View)</span>: 시스템의 기능적인 요구사항이 어떻게 제공되는지 설명해주는 뷰</li>
<li>프로세스 뷰<span style="color: #666666;">(Process View)</span>: 시스템의 비기능적인 속성으로 자원의 효율적인 사용, 병행 실행, 비동기, 이벤트 처리 등을 표현한 뷰</li>
<li>구현 뷰<span style="color: #666666;">(Implementation View)</span>: 개발 환경 안에서 정적인 소프트웨어 모듈의 구성을 보여주는 뷰, 컴포넌트 구조와 의존성을 보여주고 부가적인 정보 정의</li>
<li>배포 뷰<span style="color: #666666;">(Deployment View)</span>: 컴포넌트가 물리적인 아키텍처에 어떻게 배치되는가를 매핑해서 보여주는 뷰</li>
</ul>
<p data-ke-size="size14">◆ 비용산정 모형 분류<span style="color: #ee2323;">(ex. 2020 01)</span> <br /><br />하향식 산정방법: 경험이 많은 전무가에게 비용산정 의뢰 또는 전무가와 조정자를 통해 비용산정 <br />전문가 판단 <br />델파이 기법: 전문가의 경험적 지식을 통한 문제 해결 및 미래예측을 위한 기법 <br />상향식 산정방법: 세부적인 요구사항과기능에 따라 필요한 비용 산정 <br />코드 라인 수(LoC: Lines of Code): 원시 코드 라인수의 낙관치, 중간치, 비관치를 측정하여 예측치를 구해 비용산정 <br />Man Month: 한 사람이 1개워 동안 할 수 있는 일의 양을 기준으로 비용산정 <br />COCOMO 모형: 보헴이 제안한 모형으로 프로그램의 규모에 따라 비용산정 <br />조직형(Organic Mode): 5만(50KDSI)라인 이하 <br />반 분리형(Semi-Detached Mode): 30만(300KDSI)라인 이하 <br />임베디드형(Embedded Mode): 30만(300KDSI)라인 이상 <br />푸트남(Putnam) 모형: 개발주기의 단계별로 요구할 인력의 분포를 가정하는 방식 <br />기능점수(FP) 모형: 소프트웨어 기능을 증대시키는 요인별로 가중치를 부여하여 비용산정</p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14">◆ 디자인 패턴 유형<span style="color: #ee2323;">(ex. 2020 04, 2021 02, 2021 03)</span> <br /><br />◆ 디자인 패턴: 소프트웨어 설계에서 공통으로 발생하는 문제에 대해 자주 쓰이는 설계 방법을 정리한 패턴</p>
<p data-ke-size="size14">디자인 패턴 구성요소- 패턴 이름 / 문제 / 솔루션 / 사례 / 결과 / 샘플 코드<span style="color: #ee2323;">(패문솔 사결샘)</span></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14">◆ 디자인 패턴 유형</p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>목적
<ul style="list-style-type: disc;" data-ke-list-type="circle">
<li>생성: 객체 인스턴스 생성에 관여, 클래스 정의와 객체 생성방식을 구조화, 캡슐화를 수행하는 패턴</li>
<li>구조: 클래스나 객체의 조합을 다루는 패턴</li>
<li>행위: 클래스나 객체들이 상호 작용하는 방법과 역할 분담을 다루는 패턴</li>
</ul>
</li>
</ul>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>범위
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>클래스: 상속 관계를 다루는 패턴, 컴파일 타임에 정적으로 결정</li>
<li>객체: 객체 간 고나련서응ㄹ 다루는 패턴, 런타임에 동적으로 결정</li>
</ul>
</li>
</ul>
<p data-ke-size="size14">◆ 디자인 패턴 종류<span style="color: #ee2323;">(생구행)</span></p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>생성패턴: Builder, Prototype, Factory Method, Abstract Factory, Singleton</li>
<li>구조패턴: Bridge, Decorator, Facade, Flyweight, Proxy, Composite, Adapter</li>
<li>행위패턴: Mediator, Interpreter, Iterator, Template Method, Observer, State, Visitor, COmmand, Strategy, Memento, Chain of Responsibility</li>
</ul>
<p id="h_2" data-ke-size="size14">생성 패턴(Creational Patterns)</p>
<p data-ke-size="size14">객체 생성에 관련된 패턴입니다. 객체의 생성과 조합을 캡슐화해 특정 객체가 생성되거나 변경되어도 프로그램 구조에 영향을 크게 받지 않도록 유연성을 제공합니다.</p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><span style="color: #ee2323;">생빌 프로 팩앱싱-</span>생성(빌더 / 프로토타입 / 팩토리 메서드 / 앱스트랙 팩토리 / 싱글톤)</p>
<p data-ke-size="size14"><b><span style="color: #ee2323;">1.</span><span> </span>싱글톤 패턴<b>(Singleton)</b><span> </span>:</b><span> </span>클래스의 인스턴스가 하나임을 보장하고 접근할 수 있는 전역적인 접근점을 제공하는 패턴으로, 디자인 패턴의 가장 많이 알려진 패턴입니다.</p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><b><span style="color: #ee2323;">2.</span><span> </span>추상팩토리 패턴<b>(Abstract Factory)</b><span> </span>:</b><span> </span>구체적인 클래스를 지정하지 않고 관련성이 있거나, 독립적인 객체들을 생성하기 위한 인터페이스를 제공하는 패턴입니다.</p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><b><span style="color: #ee2323;">3.</span><span> </span>빌더 패턴<b>(Builder)</b><span> </span>:</b><span> </span>복학 객체의 생성과정과 표현과정을 분리시켜 동일한 생성과정에서 다양한 표현을 생성할 수 있는 패턴입니다.</p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><b><span style="color: #ee2323;">4.</span><span> </span>팩토리 메서드 패턴<b>(Factory Method)</b><span> </span>:</b><span> </span>객체를 생성하는 인터페이스를 정의하지만, 인스턴스를 만드는 클래스는 서브클래스에서 결정하도록 하는 패턴입니다. 팩토리 메서드에서는 인스턴스를 만드는 것을 서브 클래스에서 하게 됩니다.</p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><b><span style="color: #ee2323;">5.</span><span> </span>원형 패턴<b>(Prototype)</b><span> </span>:</b><span> </span>생성할 객체의 종류를 명시하는 데 원형이 되는 예시물을 이용하고 새로운 객체를 이 원형들을 복사함으로써 생성하는 패턴입니다.</p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"> </p>
<p id="h_3" data-ke-size="size14">구조 패턴(Structural Patterns)</p>
<p data-ke-size="size14">클래스나 객체를 조합해 더 큰 구조를 만드는 패턴입니다. 예를 들어 서로 다른 인터페이스를 지닌 2개의 객체를 묶어 단일 인터페이스를 제공하거나 서로 다른 객체들을 묶어 새로운 기능을 제공하는 패턴입니다.</p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><span style="color: #ee2323;">구 브데 퍼플 프록 컴 어</span>-구조(브리지 / 데코레이터 / 퍼사이드 / 플라이 웨이트 / 프록시 / 컴포지트 / 어댑 터)</p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><b><span style="color: #ee2323;">1.</span><span> </span>적응자 패턴(Adapter or Wrapper) :</b><span> </span>클래스의 인터페이스를 사용자가 기대하는 다른 인터페이스로 변환하는 패턴으로, 호환성이 없는 인터페이스 때문에 함께 동작할 수 없는 클래스들이 함께 작동하도록 해주는 패턴입니다.</p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><b><span style="color: #ee2323;">2.</span><span> </span>브리지 패턴(Bridge) :</b><span> </span>구현부에 추상층을 분리하여 각자 독립적으로 변형할 수 있도록 하는 패턴입니다.</p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><b><span style="color: #ee2323;">3.</span><span> </span>데코레이터 패턴(<b>Decorator<span>)</span></b><span> </span>:</b><span> </span>주어진 상황 및 용도에 따라 어떤 객체에 책임을 덧붙이는 패턴으로, 기능확장이 필요할 때 서브클래스 대신 쓸 수 있는 대안이 될 수 있습니다.</p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><b><span style="color: #ee2323;">4.</span><span> </span>퍼사드 패턴(<b>Facade<span>)</span></b><span> </span>:</b><span> </span>서브시스템에 있는 인터페이스 집합에 통합된 하나의 인터페이스를 제공합니다. 서브시스템을 좀 더 쉽게 사용하기 위해 고수준의 인터페이스를 정의합니다.</p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><b><span style="color: #ee2323;">5.</span><span> </span>프록시 패턴(<b>Proxy<span>)</span></b><span> </span>:</b><span> </span>어떤 다른 객체로 접근하는 것을 통제하기 위해 그 객체의 매니저 또는 자리 채움자를 제공하는 패턴입니다.</p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14">6. 컴포지트 패턴(Composite) : 객체들의 관계를 트리 구조로 구성하여 부분-전체 계층을 표현하는 패턴으로, 사용자가 단일 / 복합객체 모두 동일하게 다루도록 하는 패턴입니다.</p>
<p data-ke-size="size14"> </p>
<p id="h_4" data-ke-size="size14">행위 패턴(Behavioral Patterns)</p>
<p data-ke-size="size14">객체나 클래스 사이의 알고리즘이나 책임 분배에 관련된 패턴입니다. 한 객체가 혼자 수행할 수 없는 작업을 여러개의 객체로 어떻게 분배하는지, 또 그렇게 하면서도 객체 사이의 결합도를 최소화하는것에 중점을 두는 방식입니다.</p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><span style="color: #ee2323;">행 미인이 템옵 스테 비커 스트 메체-</span>행위(미디에이터 / 인터프리터 / 이터레이터 / 템플릿 메서드/ 옵져버 / 스테이트/ 비지터 / 커맨드 / 스트레티지 / 메멘토 / 체인 오브 리스판서빌리티)</p>
<p data-ke-size="size14"><b><span style="color: #ee2323;">1.</span><span> </span>옵저버 패턴<b>(Observer)</b> :</b><span> </span>객체들 사이에 1 : N 의 의존관계를 정의하여 어떤 객체의 상태가 변할 때, 의존관계에 있는 모든 객체들이 통지받고 자동으로 갱신될 수 있게 만드는 패턴입니다.</p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><b><span style="color: #ee2323;">2.</span><span> </span>상태 패턴<b>(State)</b><span> </span>:</b><span> </span>객체의 내부 상태가 변경될 때 행동을 변경하도록 허락합니다. 객체는 자신의 클래스가 변경되는 것처럼 보이게 됩니다.</p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><b><span style="color: #ee2323;">3.</span><span> </span>스트레이트지 패턴<b>(Strategy)</b><span> </span>:</b><span> </span>동일 계열의 알고리즘들을 정의하고, 각각 캡슐화하며 이들을 상호교환 가능하도록 만드는 것입니다. 알고리즘을 사용하는 사용자로부터 독립적으로 알고리즘이 변경될 수 있도록 하는 패턴입니다.</p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><b><span style="color: #ee2323;">4.</span><span> </span>템플릿 패턴<b>(Template)</b><span> </span>:</b><span> </span>객체의 연산에서 알고리즘의 뼈대만 정의하고, 나머지는 서브클래스에서 이루어지게 하는 패턴입니다. 템플릿패턴은 알고리즘의 구조는 변경하지 않고 알고리즘의 각 단계를 서브클래스에서 재정의하게 됩니다.</p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><b><span style="color: #ee2323;">5.</span><span> </span>비지터 패턴<b>(Visitor)</b> :</b><span> </span>객체구조를 이루는 원소에 대해 수행할 연산을 표현합니다. 방문자는 연산에 적용할 원소의 클래스를 변경하지 않고 새로운 연산을 재정의 할 수 있습니다.</p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><b><span style="color: #ee2323;">6.</span><span> </span>역할 사슬 패턴(<b>Chain of Responsibility)</b><span> </span>:</b><span> </span>요청을 처리하는 기회를 하나 이상의 객체에 부여하여 요청을 보내는 쪽과 받는 쪽의 결합을 피하는 패턴입니다. 요청을 받는 객체를 연쇄적으로 묶고 객체를 처리할 수 있을 때까지 요청을 전달합니다.</p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><b><span style="color: #ee2323;">7.</span><span> </span>커맨드 패턴<b>(Command)</b><span> </span>:</b><span> </span>요청을 객체로 캡슐화하여 서로 다른 사용자의 매개변수화, 요청 저장 또는 로깅, 연산의 취소를 지원하게 만드는 패턴입니다.</p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><b><span style="color: #ee2323;">8.</span><span> </span>인터프리터 패턴<b>(Interpreter)</b><span> </span>:</b><span> </span>주어진 언어에 대해서 문법을 위한 표현수단을 정의하고, 해당 언어로 된 문장을 해석하는 해석기를 사용하는 패턴입니다.</p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><b><span style="color: #ee2323;">9.</span><span> </span>이터레이터 패턴(<b>Iterator)</b><span> </span>:</b><span> </span>내부 표현부를 노출하지 않고 어떤 객체 집합의 원소들을 순차적으로 접근할 수 있는 방법을 제공하는 패턴입니다.</p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><b><span style="color: #ee2323;">10.</span><span> </span>미디에이터 패턴(Mediator) :</b><span> </span>한 집합에 속해있는 객체들의 상호 작용을 캡슐화하는 객체를 정의하는 패턴입니다. 중재자는 객체들이 직접 서로 참조하지 않도록함으로써 객체들간의 느슨한 연결을 촉진시키며 객체들의 상호작용을 독립적으로 다양화 시킬 수 있도록 해줍니다.</p>
<p data-ke-size="size14"><br /><br /></p>
<p id="--%--OSI--%--%EA%B-%--%EC%B-%B--OSI--%--Layer-" data-ke-size="size14"><a href="https://devinus.tistory.com/29#--%--OSI--%--%EA%B-%--%EC%B-%B--OSI--%--Layer-"><span>1.<span> </span><b>OSI-7 계층</b>(<b>OSI-7 Layer</b>)</span></a></p>
<p data-ke-size="size14"><span>- OSI 참조 모델은 다른 시스템 간 원활한 통신을 위해 ISO(국제표준화기구)에서 제안한 통신 규약(Protocol)이다.</span></p>
<p data-ke-size="size14"><span>-<span> </span><span style="color: #f89009;">물</span>리 -&gt;<span> </span><span style="color: #f89009;">데</span>이터 링크 -&gt;<span> </span><span style="color: #f89009;">네</span>트워크 -&gt;<span> </span><span style="color: #f89009;">전</span>송 -&gt;<span> </span><span style="color: #f89009;">세</span>션 -&gt;<span> </span><span style="color: #f89009;">표</span>현 -&gt;<span> </span><span style="color: #f89009;">응</span>용 계층 순으로 1~7 계층을 구성한다.</span></p>
<p data-ke-size="size14"><span>▶ <span style="color: #f89009;"><b>물데네전세표응</b></span></span></p>
<div>
<div>
<div>
<div>
<div>
<div>
<p data-ke-size="size16"><span><br /></span>OSI 참조모델에서의 데이터 단위</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div>
<div>
<div>
<div id="SEDOC-1519574034754--1393722348_table_0" data-attachment-id="">
<div>
<table style="border-collapse: collapse; width: 100%;" border="1" data-ke-align="alignLeft">
<tbody>
<tr>
<td colspan="1" rowspan="1">
<div>물리계층</div>
</td>
<td colspan="1" rowspan="1">
<div>비트</div>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<div>데이터링크계층</div>
</td>
<td colspan="1" rowspan="1">
<div>프레임</div>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<div>네트워크계층</div>
</td>
<td colspan="1" rowspan="1">
<div>패킷</div>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<div>전송계층</div>
</td>
<td colspan="1" rowspan="1">
<div>세그먼트</div>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<div>세션,표현,응용계층</div>
</td>
<td colspan="1" rowspan="1">
<div>메시지</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
</div>
<div>
<div>
<div>
<div>
<div>
<div> </div>
</div>
</div>
</div>
</div>
</div>
<div>
<div>
<div>
<div id="SEDOC-1519574034754--1393722348_table_1" data-attachment-id="">
<div>
<table style="border-collapse: collapse; width: 100%;" border="1" data-ke-align="alignLeft">
<tbody>
<tr>
<td colspan="1" rowspan="3">
<div>하위 계층 </div>
</td>
<td colspan="1" rowspan="1">
<div>물리계층 (Physical Layer)</div>
</td>
<td colspan="1" rowspan="1">
<div><span>- 전송에 필요한 두 장치 간의 실제 접속과<br /></span><span>  절단 등에 필요한 전송 매체의 기계적, 전기적, 기능적, 절차적 특성에 대한 규칙 정의<br /></span><span>- RS-232C 등</span></div>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<div>데이터 링크 계층 <span style="color: #000000;">(Data Link Layer)</span></div>
</td>
<td colspan="1" rowspan="1">
<div><span> - 2개의 인접한 개방 시스템들 간에 신뢰성 있고 효율적인 정보 전송을 할 수 있도록 함<br /></span><span> - 흐름제어, 프레임동기화, 오류제어, 순서제어 기능을 담당<br /></span><span> - HDLC,LAPB,PPP,LLC 등</span></div>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<div>네트워크 계층<span> </span><span style="color: #000000;">(Network Layer)</span></div>
</td>
<td colspan="1" rowspan="1">
<div><span> - 개방 시스템들 간의 네트워크 연결관리(네트워크 연결을 설정, 유지, 해제),<br /></span><span>   데이터의 교환 및 중계 기능을 담당<br /></span><span> - 경로 설정(Routing), 트래픽 제어, 패킷정보 전송<br /></span><span> - X.25,UDP등</span></div>
</td>
</tr>
<tr>
<td colspan="1" rowspan="4">
<div>상위 계층</div>
</td>
<td colspan="1" rowspan="1">
<div>전송계층 <span style="color: #000000;">(Transport Layer)</span></div>
</td>
<td colspan="1" rowspan="1">
<div><span>- 종단 시스템(End to End) 간에 투명한 데이터 전송이 가능하게 함<br /></span><span>- 전송 연결 설정, 데이터 전송, 연결해제 기능<br /></span><span>- 주소 설정, 다중화, 오류제어, 흐름제어<br /></span><span>- TCP, UDP 등</span></div>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<div>세션계층 <span style="color: #000000;">(Session Layer)</span></div>
</td>
<td colspan="1" rowspan="1">
<div><span>- 송수신측 간의 관련성을 유지하고 대화 제어를 담당<br /></span><span>- 대화 구성 및 동기제어, 데이터 교환 관리 기능<br /></span><span>- 체크점(=동기점 ): 오류가 있는 데이터의 회복을 위해<br /></span><span>  사용되는 것으로 소동기점과 대동기점이 있음</span></div>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<div>표현계층 <span style="color: #000000;">(Presentation Layer)</span></div>
</td>
<td colspan="1" rowspan="1">
<div><span>- 응용 계층으로부터 받은 데이터를 세션 계층에 맞게<br /></span><span>, 세션 계층에서 받은 데이터는 응용계층에 맞게 변환하는 기능<br /></span><span>- 코드변환, 데이터 암호화, 데이터 압축, 구문검색, 정보형식(포맷)변환 ,문맥관리 기능</span></div>
</td>
</tr>
<tr>
<td colspan="1" rowspan="1">
<div>응용계층 (Application Layer)</div>
</td>
<td colspan="1" rowspan="1">
<div>- 사용자(응용 프로그램)이 OSI 환경에 접근 할 수 있도록 서비스를 제공함</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
</div>
<p id="----%--%EB%AC%BC%EB%A-%AC%--%EA%B-%--%EC%B-%B-" data-ke-size="size14"><a href="https://devinus.tistory.com/29#----%--%EB%AC%BC%EB%A-%AC%--%EA%B-%--%EC%B-%B-"><span>1.1.<span> </span><b>물리 계층</b></span></a></p>
<table style="border-collapse: collapse; width: 100%;" border="1" data-ke-align="alignLeft">
<tbody>
<tr>
<td><span><b>프로토콜 데이터 단위</b></span><br /><span><b>(PDU; Protocol Data Unit)</b></span></td>
<td><span style="color: #f89009;">비트</span></td>
</tr>
<tr>
<td><span><b>기능</b></span></td>
<td><span style="color: #f89009;">절차적 특성에 대한 규칙정의</span></td>
</tr>
<tr>
<td><span><b>표준</b></span></td>
<td><span>RS-232C, X.21</span></td>
</tr>
<tr>
<td><span><b>관련 장비</b></span></td>
<td><span>리피터, 허브</span></td>
</tr>
</tbody>
</table>
<p data-ke-size="size14"> </p>
<p id="----%--%EB%-D%B-%EC%-D%B-%ED%--%B-%--%EB%A-%--%ED%--%AC%--%EA%B-%--%EC%B-%B-" data-ke-size="size14"><a href="https://devinus.tistory.com/29#----%--%EB%-D%B-%EC%-D%B-%ED%--%B-%--%EB%A-%--%ED%--%AC%--%EA%B-%--%EC%B-%B-"><span>1.2.<span> </span><b>데이터 링크 계층</b></span></a></p>
<table style="border-collapse: collapse; width: 100%;" border="1" data-ke-align="alignLeft">
<tbody>
<tr>
<td><span><b>프로토콜 데이터 단위</b></span><br /><span><b>(PDU; Protocol Data Unit)</b></span></td>
<td><span style="color: #f89009;">프레임</span></td>
</tr>
<tr>
<td><span><b>기능</b></span></td>
<td><span style="color: #f89009;">흐름제어, 동기화, 오류&amp;순서 제어</span></td>
</tr>
<tr>
<td><span><b>표준</b></span></td>
<td><span>HDLC, LAPB, LLC, MAC, LAPD, PPP</span></td>
</tr>
<tr>
<td><span><b>관련 장비</b></span></td>
<td><span>랜카드, 브리지, 스위치</span></td>
</tr>
</tbody>
</table>
<p data-ke-size="size14"> </p>
<p id="----%--%EB%--%A-%ED%-A%B-%EC%-B%-C%ED%--%AC%--%EA%B-%--%EC%B-%B-" data-ke-size="size14"><a href="https://devinus.tistory.com/29#----%--%EB%--%A-%ED%-A%B-%EC%-B%-C%ED%--%AC%--%EA%B-%--%EC%B-%B-"><span>1.3.<span> </span><b>네트워크 계층</b></span></a></p>
<table style="border-collapse: collapse; width: 100%;" border="1" data-ke-align="alignLeft">
<tbody>
<tr>
<td><span><b>프로토콜 데이터 단위</b></span><br /><span><b>(PDU; Protocol Data Unit)</b></span></td>
<td><span style="color: #f89009;">패킷</span></td>
</tr>
<tr>
<td><span><b>기능</b></span></td>
<td><span>경로 설정, 트래픽 제어, 패킷 정보 전송, 데이터 교환&amp;중계</span></td>
</tr>
<tr>
<td><span><b>표준</b></span></td>
<td><span>X.25,<span> </span><span style="color: #f89009;"><b>IP</b></span></span></td>
</tr>
<tr>
<td><span><b>관련 장비</b></span></td>
<td><span>리피터, 허브</span></td>
</tr>
</tbody>
</table>
<p data-ke-size="size14"> </p>
<p id="----%--%EC%A-%--%EC%--%A-%--%EA%B-%--%EC%B-%B-" data-ke-size="size14"><a href="https://devinus.tistory.com/29#----%--%EC%A-%--%EC%--%A-%--%EA%B-%--%EC%B-%B-"><span>1.4.<span> </span><b>전송 계층</b></span></a></p>
<table style="border-collapse: collapse; width: 100%;" border="1" data-ke-align="alignLeft">
<tbody>
<tr>
<td><span><b>프로토콜 데이터 단위</b></span><br /><span><b>(PDU; Protocol Data Unit)</b></span></td>
<td><span style="color: #f89009;">세그먼트</span></td>
</tr>
<tr>
<td><span><b>기능</b></span></td>
<td><span>연결 해제, 주소 설정, 다중화,<span> </span><span style="color: #f89009;">오류&amp;흐름제어</span></span></td>
</tr>
<tr>
<td><span><b>표준</b></span></td>
<td><span style="color: #f89009;"><b>TCP</b>,<span> </span><b>UDP</b></span></td>
</tr>
<tr>
<td><span><b>관련 장비</b></span></td>
<td><span>게이트웨이</span></td>
</tr>
</tbody>
</table>
<p data-ke-size="size14"> </p>
<p id="----%--%EC%--%B-%EC%--%--%--%EA%B-%--%EC%B-%B-" data-ke-size="size14"><a href="https://devinus.tistory.com/29#----%--%EC%--%B-%EC%--%--%--%EA%B-%--%EC%B-%B-"><span>1.5.<span> </span><b>세션 계층</b></span></a></p>
<table style="border-collapse: collapse; width: 100%;" border="1" data-ke-align="alignLeft">
<tbody>
<tr>
<td><span><b>프로토콜 데이터 단위</b></span><br /><span><b>(PDU; Protocol Data Unit)</b></span></td>
<td><span>메시지</span></td>
</tr>
<tr>
<td><span><b>기능</b></span></td>
<td><span>대화 구성 및 동기 제어, 데이터 교환 관리</span></td>
</tr>
</tbody>
</table>
<p data-ke-size="size14"> </p>
<p id="----%--%ED%--%-C%ED%--%--%--%EA%B-%--%EC%B-%B-" data-ke-size="size14"><a href="https://devinus.tistory.com/29#----%--%ED%--%-C%ED%--%--%--%EA%B-%--%EC%B-%B-"><span>1.6.<span> </span><b>표현 계층</b></span></a></p>
<table style="border-collapse: collapse; width: 100%;" border="1" data-ke-align="alignLeft">
<tbody>
<tr>
<td><span><b>프로토콜 데이터 단위</b></span><br /><span><b>(PDU; Protocol Data Unit)</b></span></td>
<td><span>메시지</span></td>
</tr>
<tr>
<td><span><b>기능</b></span></td>
<td><span>코드 변환, 데이터 암호화&amp;압축, 구문 검색, 정보 형식 변환, 문맥 관리</span></td>
</tr>
</tbody>
</table>
<p data-ke-size="size14"> </p>
<p id="----%--%EC%-D%--%EC%-A%A-%--%EA%B-%--%EC%B-%B-" data-ke-size="size14"><a href="https://devinus.tistory.com/29#----%--%EC%-D%--%EC%-A%A-%--%EA%B-%--%EC%B-%B-"><span>1.7.<span> </span><b>응용 계층</b></span></a></p>
<table style="border-collapse: collapse; width: 100%;" border="1" data-ke-align="alignLeft">
<tbody>
<tr>
<td><span><b>프로토콜 데이터 단위</b></span><br /><span><b>(PDU; Protocol Data Unit)</b></span></td>
<td><span>메시지</span></td>
</tr>
<tr>
<td><span><b>기능</b></span></td>
<td><span>정보 교환, 파일 전송, 전자사서함, 가상터미널</span></td>
</tr>
</tbody>
</table>
<p id="요약하기" data-ke-size="size14">요약하기</p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>OSI 7계층 &gt;&gt; 물-데-네-전-세-표-응</li>
<li>데이터 전송 단위 &gt;&gt; 물리-비트, 데이터-프레임, 네트웤-패킷, 전송-세그먼트, 그 외-데이터</li>
<li>물리 : 비트 정보를 전기적 신호로 변환 | RC-232C</li>
<li>데이터 : 데이터 전송, 오류/흐름 제어 | HDLD</li>
<li>네트워크 : 노드 간 데이터 전송, 최적 경로 설정(라우팅) | IP</li>
<li>전송 : 데이터 분할/재조립, 혼잡/흐름 제어 | TCP</li>
<li>세션 : 연결 접속 및 동기 제어 | RPC</li>
<li>표현 : 암호화/복호화 | JPEG</li>
<li>응용 : 응용 서비스 연결, 정보 교환 등 | HTTP</li>
</ul>
<p id="--%--TCP%-FIP" data-ke-size="size14"><a href="https://devinus.tistory.com/29#--%--TCP%-FIP"><span>2.<span> </span><b>TCP/IP</b></span></a></p>
<p data-ke-size="size14"><span>- 인터넷에 연결된 서로 다른 기종의 컴퓨터들이 데이터를 주고받을 수 있도록 하는 표준 프로토콜이다.</span></p>
<table style="border-collapse: collapse; width: 100%;" border="1" data-ke-align="alignLeft">
<tbody>
<tr>
<td><span><b>TPC</b></span><br /><span>(Transmission Control Protocol)</span></td>
<td><span>- OSI 7계층의<span> </span><span style="color: #f89009;"><b>전송 계층</b></span></span><br /><span>- 신뢰성 있는<span> </span><span style="color: #f89009;"><b>연결형 서비스</b></span></span><br /><span>- 패킷의 다중화, 순서 제어,<span> </span><span style="color: #f89009;">오류 제어, 흐름 제어</span><span> </span>기능</span><br /><span>-<span> </span><span style="color: #f89009;">스트림(stream) 전송</span><span> </span>기능</span></td>
</tr>
<tr>
<td><span><b>IP</b></span><br /><span>(Internet Protocol)</span></td>
<td><span>- OSI 7계층의<span> </span><span style="color: #f89009;"><b>네트워크 계층</b></span></span><br /><span>- 데이터그램을 기반으로 하는<span> </span><span style="color: #f89009;"><b>비연결형 서비스</b></span></span><br /><span>- 패킷의 분해/조립,<span> </span><span style="color: #f89009;">주소 지정, 경로 선택</span><span> </span>기능</span><br /><span>- 헤더의 길이는<span> </span><span style="color: #f89009;">최소 20Byte에서 최대 60Byte</span></span></td>
</tr>
</tbody>
</table>
<p data-ke-size="size14"> </p>
<table style="border-collapse: collapse; width: 100%;" border="1" data-ke-align="alignLeft">
<tbody>
<tr>
<td><span><b>OSI</b></span></td>
<td><span><b>TCP/IP</b></span></td>
<td><span><b>기능</b></span></td>
</tr>
<tr>
<td><span>응용 계층</span><br /><span>표현 계층</span><br /><span>세션 계층</span></td>
<td><span>응용 계층</span></td>
<td><span>- 응용 프로그램 간의 데이터 송 수신 제공</span><br /><span>- TELNET, FTP, SMTP, DNS, HTTP 등</span></td>
</tr>
<tr>
<td><span>전송 계층</span></td>
<td><span>전송 계층</span></td>
<td><span>- 호스트들 간의 신뢰서 있는 통신 제공</span><br /><span>- TCP, UDP</span></td>
</tr>
<tr>
<td><span>네트워크 계층</span></td>
<td><span>인터넷 계층</span></td>
<td><span>- 데이터 전송을 위한 주소 지정, 경로 설정을 제공</span><br /><span>- IP, ICMP, IGMP, ARP, RARP</span></td>
</tr>
<tr>
<td><span>데이터 링크 계층</span><br /><span>물리 계층</span></td>
<td><span>네트워크 액세스 계층</span></td>
<td><span>- 실제 데이터(프레임)를 송 수신하는 역할</span><br /><span>- Ethernet, IEEE 802, HDLC, X.25, RS232C, ARQ 등</span></td>
</tr>
</tbody>
</table>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14">◆ 요구공학(Requirements Engineering): 사용자의 요구가 반영된 시스템을 개발하기 위해 사용자 요구사항에 대한 도출, 분석, 명세, 호가인 및 검증하는 구조화된 활동</p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14">◆ 요구공학 프로세스: 도출 &rarr; 분석 &rarr; 명세 &rarr; 확인 및 검증<span style="color: #ee2323;">(도분명확)</span></p>
<p>[##_Image|kage@bZbz5K/btrBsFFikyI/rVxFpzjAKAKB5cwtacV3u0/img.png|CDM|1.3|{"originWidth":583,"originHeight":261,"style":"alignCenter"}_##]</p>
<p data-ke-size="size14"><span>요구사항 관리 단계(CMM Level 2 프로세스 영역) <span style="color: #f89009;"><b>(협기변확)</b></span></span></p>
<table style="border-collapse: collapse; width: 100%;" border="1" data-ke-style="style7" data-ke-align="alignLeft">
<tbody>
<tr>
<td><span>순서</span></td>
<td><span>절차</span></td>
<td><span>기법/산출물</span></td>
</tr>
<tr>
<td><span>1</span></td>
<td><span>요구사항 <span style="color: #f89009;"><b>협</b></span>상</span></td>
<td><span>우선순위 설정, 시물레이션</span></td>
</tr>
<tr>
<td><span>2</span></td>
<td><span>요구사항 <span style="color: #f89009;"><b>기</b></span>준선 설정</span></td>
<td><span>공식 회의, 형상 관리</span></td>
</tr>
<tr>
<td><span>3</span></td>
<td><span>요구사항 <span style="color: #f89009;"><b>변</b></span>경관리</span></td>
<td><span>형상통제 위원회, 영향도 분석</span></td>
</tr>
<tr>
<td><span>4</span></td>
<td><span>요구사항 <span style="color: #f89009;"><b>확</b></span>인 및 검증</span></td>
<td><span>확인 및 검증</span></td>
</tr>
</tbody>
</table>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><span>요구사항 개발 단계(CMM Level 3 프로세스 영역)<span> </span><b><span style="color: #f89009;">(도분명확)</span></b></span></p>
<table style="border-collapse: collapse; width: 100%;" border="1" data-ke-style="style7" data-ke-align="alignLeft">
<tbody>
<tr>
<td><span>순서</span></td>
<td><span>절차</span></td>
<td><span>내용</span></td>
</tr>
<tr>
<td><span>1</span></td>
<td><span>요구사항<span> </span><span style="color: #f89009;"><b>도</b></span>출</span></td>
<td><span>문제 이해, 정보 식별, 수집 방법 결정</span></td>
</tr>
<tr>
<td><span>2</span></td>
<td><span>요구사항<span> </span><span style="color: #f89009;"><b>분</b></span>석</span></td>
<td><span>요구사항 분석 활동</span></td>
</tr>
<tr>
<td><span>3</span></td>
<td><span>요구사항<span> </span><span style="color: #f89009;"><b>명</b></span>세</span></td>
<td><span>문서 작성 단계</span></td>
</tr>
<tr>
<td><span>4</span></td>
<td><span>요구사항<span> </span><span style="color: #f89009;"><b>확</b></span>인 및 검증</span></td>
<td><span>확인(Validation), 검증(Verfication) 단계</span></td>
</tr>
</tbody>
</table>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14">2장 화면 설계</p>
<p data-ke-size="size14">◆ UI(User Interface): 사용자와 시스템 사이에서 의사소통 할 수 있도록 고안된 물리적, 가상의 매개체</p>
<p data-ke-size="size14">UX- 사람의 감정이나 경험을 나타내는 개념 <br />UI- 사용자 인터페이스. 예로는 CLI이 있다.</p>
<p data-ke-size="size14">◆ UI유형<span style="color: #ee2323;">(CG NO)</span></p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>CLI(Command Line Interface): 명령어를 텍스트로 입력하여 조작하는 사용자 인터페이스</li>
<li>GUI(Graphical User Interfae): 그래픽 환경을 기반으로 한 마우스나 전자펜을 이용한 사용자 인터페이스</li>
<li>NUI(Natural User Interface): 신체 부위를 이용하는 사용자 인터페이스</li>
<li>OUI(Organic User Interface): 현실에 존재하는 모든 사물이 입출력장치로 변화할 수 있는 사용자 인터페이스</li>
</ul>
<p data-ke-size="size14"><span><span>UI 설계 원칙</span><b><span> </span><span style="color: #f89009;">(직유 학유)</span></b></span></p>
<table style="border-collapse: collapse; width: 100%;" border="1" data-ke-style="style7" data-ke-align="alignLeft">
<tbody>
<tr>
<td><span>설계 원칙</span></td>
<td><span>설명</span></td>
<td><span>부특성</span></td>
</tr>
<tr>
<td><span><span style="color: #f89009;"><b>직</b></span>관성</span><br /><span>(Intuitiveness)</span></td>
<td><span>누구나 쉽게 이해하고, 쉽게 사용할 수 있어야 함</span></td>
<td><span>쉬운 검색</span><br /><span>쉬운 사용성</span><br /><span>일관성</span></td>
</tr>
<tr>
<td><span><span style="color: #f89009;"><b>유</b></span>효성</span><br /><span>(Efficiency)</span></td>
<td><span>정확하고 완벽하게 사용자의 목표가 달성될 수 있도록 제작</span></td>
<td><span>쉬운 오류 처리 및 복구</span></td>
</tr>
<tr>
<td><span><span style="color: #f89009;"><b>학</b></span>습성</span><br /><span>(Learnability)</span></td>
<td><span>초보와 숙련자 모두가 쉽게 배우고 사용할 수 있게 제작</span></td>
<td><span>쉽게 학습</span><br /><span>쉬운 접근</span><br /><span>쉽게 기억</span></td>
</tr>
<tr>
<td><span><span style="color: #f89009;"><b>유</b></span>연성</span><br /><span>(Flexibility)</span></td>
<td><span>사용자의 인터랙션을 최대한 포용하고, 실수를 방지할 수 있도록 제작</span></td>
<td><span>오류 예방</span><br /><span>실수 포용</span><br /><span>오류 감지</span></td>
</tr>
</tbody>
</table>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14">◆ UI 설계 지침<span style="color: #ee2323;">(사일단결 가표접명오)</span>: 사용자 중심, 일관성, 단순성, 결과 예측 가능, 가시성, 표준화, 접근성, 명확성, 오류 발생 해결</p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14">◆ UI 품질 요구사항(ISO/IEC 9126 기반)<span style="color: #ee2323;">(기신사효유이)</span></p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>기능성: 실제 수행 결과와 품질 요구사항과의 차이를 분석, 시스템 동작을 관찰하기 위한 품질 기준
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>적절성, 정밀성, 상호 운용성, 보안성, 호환성</li>
</ul>
</li>
<li>신뢰성: 시스템이 일정한 시간 또는 작동되는 시간동안 의도하는 기능을 수행함을 보증하는 품질 기준
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>성숙성, 고장 허용성, 회복성</li>
</ul>
</li>
<li>사용성: 사용자와 컴퓨터 사이에 발생하는 어떠한 행위를 정확하고 쉽게 인지할 수 있는 품질 기준
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>이해성, 학습성, 운용성</li>
</ul>
</li>
<li>효율성: 할당된 시간에 한정된 자원으로 얼마나 빨리 처리할 수 있는가에 대한 품질 기준
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>시간 효율성, 자원 효율성</li>
</ul>
</li>
<li>유지보수성: 요구사항을 개선하고 확장하는 데 있어 얼마나 용이한가에 대한 품질 기준
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>분석성, 변경성, 안정성, 시험성</li>
</ul>
</li>
<li>이식성: 다른 플랫폼에서도 추가 작업 없이 얼마나 쉽게 적용 가능한가에 대한 품질 기준
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>적용성, 설치성, 대체성</li>
</ul>
</li>
</ul>
<p data-ke-size="size14">◆ UI 화면 설계 구분<span style="color: #ee2323;">(와스프)</span></p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>와이어프레임: 화면 단위의 레이아웃을 설계하는 작업 (ppt, 키노트, 스케치, 일러스트)</li>
<li>스토리보드: 서비스 구축을 위한 모든 정보(정책, 프로세스,와이어프레임, 기능 정의 등)가 담겨 있는 설계 산출물 (ppt, 키노트, 스케치)</li>
<li>프로토타입: 정적인 화면(와이어프레임, 스토리보드)에 동적 효과를 적용하여 실제 구현된 것처럼 시뮬레이션 할 수 있는 모형. 전체적인 기능을 간략한 형태로 구현한 시제품 (HTML, CSS)</li>
</ul>
<p data-ke-size="size14">◆ UML(Unified Modeling Language): 객체 지향 소프트웨어 개발 과정에서 산출물을 명세화, 시각화, 문서화할 때 사용되는 모델링 기술과 방법론을 통합해서 만든 표준화된 범용 모델링 언어</p>
<p data-ke-size="size14">◆ UML 특징<span style="color: #ee2323;">(가구명문)</span>: 가시화 언어, 구축 언어, 명세화 언어, 문서화 언어</p>
<p data-ke-size="size14">◆ UML 구성요소<span style="color: #ee2323;">(사관다)</span>:</p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li><span>사물 Things</span></li>
<li><span>관계 Relationships</span></li>
<li><span>다이어그램 Diagrams</span></li>
</ul>
<p data-ke-size="size14">◆ UML다이어그램</p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>구조적 다이어그램 / 정적 다이어그램<span style="color: #ee2323;">(클객컴배복패)</span>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>클래스(Class): 클래스의 속성 및 연산과 클래스간 정적인 관계를 표현</li>
<li>객체(Object): 클래스에 속한 사물(객체 =인스턴스)를 특정 시점의 객체와 객체 사이의 관계로 표현</li>
<li>컴포넌트(Component): 시스템을 구성하는 물리적인 컴포넌트와 그들 사이의 의존 관계 표현</li>
<li>배치(Deployment): 컴포넌트 사이의 종속성을 표현하고, 물리적 요소들의 위치를 표현</li>
<li>복합체 구조(Composite Structure): 클래스나 컴포넌트가 복합 구조를 갖는 경우 그 내부 구조를 표현</li>
<li>패키지(Package): 유스케이스, 클래스 등의 모델 요소들을 그룹화한 패키지들의 관계</li>
</ul>
</li>
<li>행위적 다이어그램 / 동적 다이어그램<span style="color: #ee2323;">(유시쿼상활타)</span>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>유스케이스(Usecase): 시스템이 제공하고 있는 기능 및 그와 관련된 외부 요소를 사용자의 곤점에서 표현</li>
<li>시퀀스(Sequence): 객체 간 동적 상호 작용을 시간적 개념을 중심으로 메시지 흐름으로 표현</li>
<li>커뮤니케이션(Communication): 동작에 참여하는 객체들이 주고받는 메시지를 표현하고, 객체 간의 연관까지 표현</li>
<li>상태(State): 자신이 속한 클래스의 상태 변화 혹은 다른 객체와의 상호 작용에 따라 상태가 어떻게 변화하는지 표현</li>
<li>활동(Activity): 객체의 처리 로직이나 조건에 따른 처리의 흐름을 순서대로 표현</li>
<li>타이밍(Timing): 객체 상태 변화와 시간 제약을 명시적으로 표현</li>
</ul>
</li>
</ul>
<p data-ke-size="size14"><span>스케이스 다이어그램의 구성요소</span></p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li><span>유스케이스(Usecase)</span></li>
<li><span>액터(Actor)</span></li>
<li><span>시스템(System)</span></li>
</ul>
<p id="ui-시나리오-문서의-요건" data-ke-size="size14">UI 시나리오 문서의 요건<span style="color: #ee2323;">(완일이가 추수)</span></p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>완전성 (Complete)
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>누락되지 않도록 최대한 상세하게 기술</li>
<li>기능보다<span> </span><b>사용자의 태스크에 초점</b></li>
</ul>
</li>
<li>일관성 (Consistent)
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>서비스 목표, 요구사항, 스타일 등이 모두 일관성 유지</li>
</ul>
</li>
<li>이해성 (Understandable)
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>누구나 쉽게 이해할 수 있도록 불분명하거나 추상적인 표현은 배제</li>
</ul>
</li>
<li>가독성 (Readable)
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li><b>표준화된 템플릿</b><span> </span>등을 활용하여 문서를 쉽게 읽을 수 있도록</li>
<li>하이퍼링크를 지정하여 문서들이 서로 참조될 수 있도록 지정</li>
</ul>
</li>
<li>수정 용이성 (Modifiable)
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>시나리오의 수정이나 개선이 용이해야 함</li>
</ul>
</li>
<li>추적 용이성 (Traceable)
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>변경 사항을 쉽게 추적할 수 있어야 함</li>
</ul>
</li>
</ul>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14">3장 데이터 입출력 구현</p>
<p data-ke-size="size14">◆ 데이터 모델(Data Model): 현실 세계의 정보를 인간과 컴퓨터가 이해할 수 있도록 추상화하여 표현한 모델 <br /><br />◆ 데이터 모델 절차(요개논물구)<span style="color: #ee2323;">(ex. 2021 01)</span>: 요구사항 분석 &rarr; 개념적 설계(concept) &rarr; 논리적 설계(Logical) &rarr; 물리적 설계(physic) &rarr; 구현</p>
<p data-ke-size="size14">개념적 설계는 현실 세계에 대한 인식을 추상적, 개념적으로 표현하여 개념적 구조를 도출하는 과정으로 주요 산출물에는 E-R 다이어그램이 있다. <br />논리적 설계은/는 특정 DBMS의 특성 및 성능을 고려하여 데이터베이스 저장 구조로 변환하는 과정으로 결과로 나오는 명세서는 테이블 정의서 등이 있다.<br />물리적 설계은/는 목표 DBMS에 맞는 스키마 설계, 트랜잭션 인터페이스를 설계하는 정규화 과정을 수행한다.<br /><br />데이터 모델에 표시할 요소<span style="color: #ee2323;">(ex. 2021 01)</span> <br />- 구조 (Structure) : 논리적으로 표현된 개체 타입들 간의 관계로서 데이터 구조 및 정적 성질을 표현 <br />- 연산 (Operation) : DB에 저장된 실제 데이터를 처리하는 작업에 대한 명세로서 조작하는 기본 도구 <br />- 제약 조건 (Constraint) : DB에 저장될 수 있는 실제 데이터의 논리적인 제약 조건</p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14">◆ 논리 데이터 모델링: 업무의 모습을 모델링 표기법으로 형상화하여 사람이 이해하기 쉽게 표현하는 프로세스</p>
<p data-ke-size="size14">◆ 논리적 데이터 모델링 종류</p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>관계 데이터 모델: 테이블 형태, 1:1, 1:N, N:M</li>
<li>계층 데이터 모델: 트리 형태(상하 관계), 1:N</li>
<li>네트워크 데이터 모델: 그래프 형태, N:M</li>
</ul>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li><b>관계형 데이터베이스의 관계대수</b></li>
</ul>
<p data-ke-size="size14"><span>- 관계형 데이터베이스에서 원하는 정보를 얻기 위해 어떻게 유도하는가를 기술하는<span> </span><b>절차적</b><span> </span>언어</span></p>
<p data-ke-size="size14"><span>- 관계대수에는<span> </span><u>순수 관계 연산자</u>와 수학적 집합 이론에서 사용하는<span> </span><u>일반 집합 연산자</u>가 존재</span></p>
<p data-ke-size="size14"><span>순수 관계 연산자 : Select, Project, Join, Division</span><br /><span>일반 집합 연산자 : UNION(합집합), INTERSECTION(교집합), DIFFERENCE(차집합), CARTESIAN PRODUCT(교차곱)</span></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><b><span>순수 관계 연산자</span></b></p>
<p data-ke-size="size14"><span><b>Select</b></span></p>
<p data-ke-size="size14"><span>-<span> </span><b>선택 조건</b>을 만족하는 튜플의 부분집합을 구해 새로운 릴레이션을 만드는 연산</span></p>
<p data-ke-size="size14"><span>- 행에 해당하는 튜플을 구하는 것으로<span> </span><u>수평 연산</u>이라고도 함</span></p>
<p data-ke-size="size14"><span>표기 형식 : &sigma;&lt;조건&gt;(R)</span></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><b><span>Project</span></b></p>
<p data-ke-size="size14"><span>- 속성 리스트에 제시된<span> </span><b>속성 값만을 추출</b>해 새로운 릴레이션을 만드는 연산</span></p>
<p data-ke-size="size14"><span>- 연산 결과에 중복이 발생하면 중복이 제거됨</span></p>
<p data-ke-size="size14"><span>- 열에 해당하는 속성을 추출하는 것으므로<span> </span><u>수직 연산</u>이라고도 함</span></p>
<p data-ke-size="size14"><span>표기 형식 : &pi;&lt;속성리스트&gt;(R)</span></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><b><span>Join</span></b></p>
<p data-ke-size="size14"><span>-<span> </span><b>공통 속성을 중심</b>으로<span> </span><b>두개의 릴레이션을 하나로 합쳐</b><span> </span>새로운 릴레이션을 만드는 연산</span></p>
<p data-ke-size="size14"><span>- Join의 결과로 만들어진 릴레이션의 차수는 조인된 두 릴레이션의 차수를 합한 것과 같음</span></p>
<p data-ke-size="size14"><span><span>표기 형식 : R<span> </span></span>⋈키속성r=키속성s S</span></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><b><span>Division</span></b></p>
<p data-ke-size="size14"><span>- X&sup;Y 인 두 릴레이션 R(X), S(Y)가 있을 때 R의 속성이 S의 속성값을 모두 가진 튜플에서 S가 가진 속성을 제외한 속성만을 구하는 연산</span></p>
<p data-ke-size="size14"><span>표기 형식 : R [속성r &divide; 속성s] S</span></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><b><span>일반 집합 연산자</span></b></p>
<p data-ke-size="size14"><span>- 합집합, 교집합, 차집합을 처리하기 위해서는 합병조건을 만족해야 함</span></p>
<p data-ke-size="size14"><span>- 합병 가능한 두 릴레이션 R과 S가 있을 때 각 연산의 특징은 다음과 같음</span></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><span>*합병조건 : 합병하려는 두 릴레이션 간의 속성 수가 같고 대응되는 속성별로 도메인이 같아야 함</span></p>
<p data-ke-size="size14"> </p>
<div>
<table style="border-collapse: collapse; width: 100%;" border="1" data-ke-align="alignLeft">
<tbody>
<tr>
<td><b><span>연산자</span></b></td>
<td><b><span>기능</span></b></td>
<td><b><span>카디널리티</span></b></td>
</tr>
<tr>
<td><b><span>합집합</span></b><br /><b><span>UNION (&cup;)</span></b></td>
<td><span>- 두 릴레이션에 존재하는 튜플의 합집합</span><br /><span>- 중복되는 튜플은 제거됨</span></td>
<td><span>- 합집합의 카디널리티는 두 릴리에션 카디널리티의 합보다 크지 않음</span></td>
</tr>
<tr>
<td><b><span>교집합</span></b><br /><b><span>INTERSECTION (&cap;)</span></b></td>
<td><span>- 두 릴레이션에 존재하는 튜플의 교집합</span></td>
<td><span>- 교집합의 카디널리티는 두 릴레이션 중 카디널리티가 적은 릴레이션의 카디널리티보다 크지 않음</span></td>
</tr>
<tr>
<td><b><span>차집합</span></b><br /><b><span>DIFFERENCE (-)</span></b></td>
<td><span>- 두 릴레이션에 존재하는 튜플의 차집합</span></td>
<td><span>- 차집합의 카디널리티는 빼지는 릴레이션의 카디널리티보다 크지 않음</span></td>
</tr>
<tr>
<td><b><span>교차곱</span></b><br /><b><span>CARTESIAN PRODUCT(x)</span></b></td>
<td><span>- 두 릴레이션에 있는 튜플들의 순서쌍</span></td>
<td><span>- 교차곱의 카디널리티는 두 릴레이션의 카디널리티를 곱한 것과 같음</span></td>
</tr>
</tbody>
</table>
</div>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><span><b>관계형 데이터베이스의 관계해석</b></span></p>
<p data-ke-size="size14"><span>- 수학의 Predicate Calculus (술어해석)에 기반을 두고 있음</span></p>
<p data-ke-size="size14"><span>- 원하는 정보가 무엇이라는 것만 정의하는<span> </span><b>비절차적</b><span> </span>특성을 지님</span></p>
<p data-ke-size="size14"><span>- 관계대수로 표현한 식은 관계해석으로 표현할 수 있음 </span></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14">◆ 관계 해석: 튜플 관계해석과 도메인 해석을 하는 비절차적 언어</p>
<p data-ke-size="size14">◆ 논리 데이터 모델링 속성<span style="color: #ee2323;">(개속관)</span>: 개체(Entitiy), 속성(Attributes), 관계(Relationship)</p>
<p data-ke-size="size14">◆ 개체-관계(E-R) 모델: 데이터와 그들간의 관계를 사람이 이해할 수 있는 형태로 표현한 모델</p>
<p data-ke-size="size14">◆ 정규화: 데이터 모델에서 데이터의 중복성을 제거하여 이상 현상을 방지하고, 데이터의 일관성과 정확성을 유지하기 위해 무손실 분해하는 과정</p>
<p data-ke-size="size14">◆ 이상현상(Anomaly)<span style="color: #ee2323;">(삽삭갱)</span>: 데이터의 중복성으로 인해 릴레이션을 조작할때 발생하는 비합리적 현상</p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>삽입이상: 불필요한 세부정보 입력하는 경우</li>
<li>삭제이상: 원치 않는 다른 정보가 같이 삭제되는 경우</li>
<li>갱신이상: 특정부분만 수정되어 중복된 값이 모순을 일으키는 경우</li>
</ul>
<p data-ke-size="size14">◆ 정규화 단계<span style="color: #ee2323;">(원부이결다조)</span></p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>1정규형(1NF): 도메인이 원자값으로 구성</li>
<li>2정규형(2NF): 부분함수 종속제거 (완전 함수적 종속을 만족)</li>
<li>3정규형(3NF): 이행함수 종속제거</li>
<li>보이스-코드 정규형(BCNF): 결정자 후보 키가 아닌 함수 종속 제거</li>
<li>4정규형(4NF): 다중 값 종속제거</li>
<li>5정규형(5NF): 조인 종속 제거</li>
</ul>
<p data-ke-size="size14">◆ 반정규화(De-Nomalization)<span style="color: #ee2323;">(테병분중 컬중 관중)</span>:</p>
<p id="toc11" data-ke-size="size14"><span style="color: #000000;"><b>반정규화(Denormalization)의 개념</b></span></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><span style="color: #000000;">반정규화란 시스템의 성능 향상, 개발 및 운영의 편의성 등을 위해 정규화된 데이터를 통합, 중복, 분리하는 과정으로 의도적으로 정규화 원칙을 위배하는 행위이다. </span></p>
<p data-ke-size="size14"><span style="color: #000000;"><br /><b><span style="color: #006dd7;">-시스템 성능이 향상되고 관리 효율성 증가</span></b><br /><b><span style="color: #006dd7;">-사전에 데이터 일관성과 무결성을 우선으로 할지, 데이터베이스의 성능과 단순화를 우선으로 할지 결정<br />-테이블통합, 테이블 분할, 중복 테이블 추가, 중복 속성 추가 등이 있다</span></b><br /><br /><b><span style="color: #ee2323;">-데이터 일관성 및 정합성 저하</span></b><br /><b><span style="color: #ee2323;">-과도한 반정규화는 성능저하</span></b></span></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14">(테이블) 병합 / 분할 / 중복, (컬럼) 중복, (관계) 중복</p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><b><span>2) 연계 매커니즘</span></b></p>
<p data-ke-size="size14"><b><span>- 데이터 생성과 전송을 담당하는 송신 체계와 데이터 수신과 DB 반영을 담당하는 수신 체계로 구성</span></b></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><b><span>&lt; 연계 방식 &gt;</span></b></p>
<p data-ke-size="size14"><b><span><span style="color: #ee2323;">* 직접 연계</span><span> </span>: 중간 매개체 없이 송수신 시스템 연결</span></b></p>
<p data-ke-size="size14"><span><b>- DB Link</b><span> </span>: DB에서 제공하는<span> </span><span style="color: #ee2323;"><b>DB 링크 객체</b></span><span> </span>이용</span></p>
<p data-ke-size="size14"><span><b>- DB Connection</b><span> </span>:<span> </span><span style="color: #ee2323;"><b>DB Connection Pool</b></span><span> </span>생성</span></p>
<p data-ke-size="size14"><span><b>- API/Open API<span> </span></b>:<span> </span><span style="color: #ee2323;"><b>API 생성</b></span></span></p>
<p data-ke-size="size14"><span>- JDBC : JDBC 드라이브 이용</span></p>
<p data-ke-size="size14"><span>- Hyper Link : 링크 속성, Hub &amp; Spoke + ESB, 병목 현상 최소화</span></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><b><span><span style="color: #ee2323;">* 간접 연계</span><span> </span>: 중간 매개체를 통한 연계</span></b></p>
<p data-ke-size="size14"><span><b>- EAI</b><span> </span>:<span> </span><b>기업에서 운영되는 이기종 간 시스템 연계 솔루션</b></span></p>
<p data-ke-size="size14"><span><b>- ESB/Web Service</b><span> </span>: WSDL과 SOAP 프로토콜을 이용한 시스템 연계</span></p>
<p data-ke-size="size14"><span><b>- Socket</b><span> </span>: 포트 할당, 클라이언트 요청 연결</span></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><b><span>* 연계 메커니즘 주행 절차</span></b></p>
<p data-ke-size="size14"><span>연계 데이터 추출 생성 -&gt; 코드 매핑/변환 -&gt; 파일 생성 -&gt; 로그 기록 -&gt; 송수신 어댑터 -&gt; 전송 -&gt; 반영</span></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><b><span>3) 연계 모듈 기능 구현<span style="color: #ee2323;">(포허메하)(ex. 2020 03, 2021 01)</span></span></b></p>
<p data-ke-size="size14"><b><span>- EAI : 기업에서 운영되는 이기종 간 시스템 연계 솔루션</span></b></p>
<p data-ke-size="size14"><span><b>- Point &ndash; to Point</b><span> </span>: 가장 기본적, 변경 재사용 어려움</span></p>
<p data-ke-size="size14"><span><b>- Hub &amp; Spoke :</b><span> </span>허브 시스템, 확장, 유지보수 용이</span></p>
<p data-ke-size="size14"><span><b>- Message Bus(ESB)</b><span> </span>: 미들웨어를 두고 처리, 뛰어난 확장성</span></p>
<p data-ke-size="size14"><span><b>- Hybrid</b><span> </span>: Hub &amp; Spoke + ESB, 병목 현상 최소화</span></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><span><b>* ESB</b><span> </span>: 기업에서 운영되는 이기종 간의 서비스를 통합하여 하나의 시스템으로 관리 운영할 수 있는 기술</span></p>
<p data-ke-size="size14"><span><b>- 느슨한 결합</b><span> </span>: 특정 서비스를 변경해도 연결된 다른 서비스에 영향을 주지 않는 구조</span></p>
<p data-ke-size="size14"><span><span>- 개발자가 서비스를 개발하고 적절한 API를 통해 서비스 간에 통신을 하는데 도움이 되는 인프라 스트럭처 소프트웨어</span></span></p>
<p data-ke-size="size14"><span>- SOA가 실현되는 플랫폼으로 사용될 수 있지만 ESB는 서비스가 흐르는 매체일 뿐이고 SOA의 구현과 서비스 구성 및 배치를 위한 기능을 제공</span></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><b><span>2) EAI(Enterprise Application Interface)<span style="color: #ee2323;">(포허메하)</span></span></b></p>
<p data-ke-size="size14"><b><span>-<span> </span><span style="color: #ee2323;">기업에서 운영되는 이기종 간의 시스템 연계 솔루션</span></span></b></p>
<table style="border-collapse: collapse; width: 100%;" border="1" data-ke-style="style8" data-ke-align="alignLeft">
<tbody>
<tr>
<td colspan="2"><b><span>EAI 방식 종류</span></b></td>
</tr>
<tr>
<td><b><span>Point to Point 방식</span></b></td>
<td><span>1:1 단순 통합 방식</span></td>
</tr>
<tr>
<td><b><span>Hub &amp; Spoke 방식</span></b></td>
<td><span>허브 시스템을 통하여 데이터를 전송하는 중앙 집중형 방식</span></td>
</tr>
<tr>
<td><b><span>Message Bus 방식</span></b></td>
<td><span>애플리케이션 사이에 미들웨어를 두고 연계하는 방식</span></td>
</tr>
<tr>
<td><b><span>Hybrid 방식</span></b></td>
<td><span>내부 - H</span></td>
</tr>
</tbody>
</table>
<p data-ke-size="size14"><b><span>7) 인터페이스 구현 검증(단답형)<b><span><span style="color: #ee2323;">(엑스피엔셀웨)</span></span></b></span></b></p>
<p data-ke-size="size14"><span>- <b>xUnit</b></span></p>
<p id="SE-9b0700d1-ad9b-40e9-9594-bac61bf0a8ff" data-ke-size="size14"><span>:JAVA(Junit), C++(Cppunit), .Net(Nunit) 등<b> </b><span style="color: #ee2323;"><b>다양한 언어를 지원하는 단위 테스트 프레임워크</b></span></span></p>
<p data-ke-size="size14"> </p>
<p id="SE-8fe7284a-c0af-4838-bd50-bd87c6f2f9c8" data-ke-size="size14"><span>- <b>STAF</b></span></p>
<p id="SE-59ada15f-152f-416c-849b-47b0ec9431c4" data-ke-size="size14"><span>:<span style="color: #ee2323;"><b> 서비스 호출 및 컴포넌트 재사용</b></span> 등 다양한 환경을 지원하는 테스트 프레임워크</span></p>
<p data-ke-size="size14"> </p>
<p id="SE-bcf7546a-86fc-4bf7-8acb-3a9381094548" data-ke-size="size14"><span>- <b>FitNesse</b></span></p>
<p id="SE-0720368a-2d7a-48be-b507-bf33648d36fa" data-ke-size="size14"><span>: ​<span style="color: #ee2323;"><b>웹 기반 테스트케이스 설계, 실행, 결과 확인</b></span> 등을 지원하는 테스트 프레임워크</span></p>
<p data-ke-size="size14"> </p>
<p id="SE-adeaa887-be0c-4d1f-9e4a-d6a016356c7d" data-ke-size="size14"><span>- <b>NTAF</b></span></p>
<p id="SE-86f3e2c5-143b-4386-a461-c175812c6c4d" data-ke-size="size14"><span>: FitNesse의 장점인 협업 기능과 STAF의 장점인 재사용 및 확장성을 통합한<span style="color: #ee2323;"><b> NHN(Naver)의 테스트 자동화</b></span> 프레임워크</span></p>
<p data-ke-size="size14"> </p>
<p id="SE-a28fd4b2-bac4-4348-a137-5d00c587d015" data-ke-size="size14"><span>- <b>Selenium</b></span></p>
<p id="SE-94c65c27-5b0a-423b-8c1f-17457cf57a23" data-ke-size="size14"><span>:<span style="color: #ee2323;"> ​<b>다양한 브라우저 및 개발 언어를 지원</b></span>​하는 웹 애플리케이션 테스트 프레임워크</span></p>
<p data-ke-size="size14"> </p>
<p id="SE-013e8ed6-65dc-4ce8-98a8-89a8362267d3" data-ke-size="size14"><span>- <b>watir</b></span></p>
<p id="SE-db995776-1359-40ad-ad09-a807c2db66d5" data-ke-size="size14"><span>: <span style="color: #ee2323;"><b>Ruby를 사용</b></span>하는 애플리케이션 테이트 프레임워크</span></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><span>6장 프로그래밍 언어 활용</span></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14">- 변수 명명법</p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><b>Pascal Casing(파스칼 케이싱)</b><span> </span>: 대문자로 시작하는 변수명을 사용</p>
<p data-ke-size="size14">-&gt; 복잡어일 경우 중간에 시작하는 새로운 단어는 대문자로 적는다.</p>
<p data-ke-size="size14">-&gt;<span> </span><b>HumanResource</b></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><b>Camel Casing(카멜 케이싱)</b><span> </span>: 첫번째 문자는 소문자로 시작하고 복잡어일 경우 파스칼 케이싱과 동일</p>
<p data-ke-size="size14">-&gt;<span> </span><b>getName</b></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><b>GNU Naming(snake)</b><span> </span>: 모두 소문자를 사용하고 복합어 사이를 '_'를 사용하여 연결</p>
<p data-ke-size="size14">-&gt;<span> </span><b>human_resource</b></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14">-<span> </span><b>Hungarian notation(헝가리안 표기법)</b><span> </span>: 첫글자<span> </span><b>g는 전역변수</b>,<span> </span><b>m은 멤버변수</b><span> </span>의미</p>
<p data-ke-size="size14">-&gt; 전역이나 멤버변수의 경우 그 다음에 _를 적는다.</p>
<p data-ke-size="size14">-&gt;<span> </span><b>n과 i는 자연수</b>, i는 주로 인덱스, n은 카운트 목적에 주로 사용</p>
<p data-ke-size="size14">-&gt;<span> </span><b>g_name</b>,<span> </span><b>n_Cnt</b></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14">-<span> </span><b>GNU Naming Convention</b><span> </span>: 모든 문자를 대문자로 사용하는 GNU Naming Convention의 형태를 사용</p>
<p data-ke-size="size14">-&gt;<span> </span><b>DEFAULT_DEPARTMENT_CODE</b></p>
<p data-ke-size="size14">- 대표적인 스크립트 언어</p>
<ul style="list-style-type: disc;" data-ke-list-type="circle">
<li><b>JavaScript</b><span> </span>: 미국 넷스케이프에서 개발 -&gt; Java와 기능상 아무런 관련이 없다.</li>
<li><b>JSP</b><span> </span>: Java Server Pages의 약자, 웹 페이지 동적 생성</li>
<li><b>PHP</b><span> </span>: 서버 측 스크립트 프로그래밍 언어</li>
<li><b>ASP</b><span> </span>: Active Server Pages의 약자, MS윈도우 서버에서 운영되는 서버 측 스크립트 언어</li>
<li>펄(Perl) Practical Extraction and Report Language의 약자 -&gt; 텍스트 처리에 주안점을 두고 개발된 스크립트 언어로 CGI 개발에 사용</li>
<li><b>Python</b><span> </span>: 플랫폼 독집적, 인터프리터식, 객체지향적, 동적타이핑의 대화형 언어</li>
</ul>
<p data-ke-size="size14"> </p>
<p id="toc23" data-ke-size="size14"><span>절차적 프로그래밍 언어의 종류</span></p>
<table style="border-collapse: collapse; width: 100%;" border="1" data-ke-style="style12" data-ke-align="alignLeft">
<tbody>
<tr>
<td><span><b>언어</b></span></td>
<td><span><b>특징</b></span></td>
</tr>
<tr>
<td><span>C</span></td>
<td><br /><span>  ✔ 시스템 소프트웨어 개발 편리 / 시스템 프로그래밍 언어로 가장 적합</span><br /><span>  ✔ 자료 주소를 조작할 수 있는 포인터 제공</span><br /><span>  ✔ 고급 언어이면서 저급 언어의 특징을 모두 갖춤</span><br /><span>  ✔ 컴파일러 방식의 언어</span><br /><span>  ✔ 이식성이 좋아 컴퓨터 기종에 관계 없이 프로그램 작성 가능</span><br /><br /></td>
</tr>
<tr>
<td><span>ALGOL</span></td>
<td><br /><span>  ✔ 수치 계산이나 논리 연산을 위한 과학 기술 계산용 언어</span><br /><span>  ✔ pascal과 c언어의 모체</span><br /><br /></td>
</tr>
<tr>
<td><span>COBOL</span></td>
<td><br /><span>  ✔ 사무 처리용 언어</span><br /><span>  ✔ 영어 문장 형식으로 구성되어 있어 이해와 사용 쉬움</span><br /><span>  ✔ 4개의 DIVISION으로 구성</span><br /><br /></td>
</tr>
<tr>
<td><span>FORTRAN</span></td>
<td><br /><span>  ✔ 과학 기술 계산용 언어</span><br /><span>  ✔ 수학/공학 분야의 공식이나 수식과 같은 형태로 프로그래밍 가능✔</span></td>
</tr>
</tbody>
</table>
<p data-ke-size="size14"> </p>
<p id="toc33" data-ke-size="size14"><span><b>객체지향 프로그래밍 언어의 종류</b></span></p>
<table style="border-collapse: collapse; width: 100%;" border="1" data-ke-style="style12" data-ke-align="alignLeft">
<tbody>
<tr>
<td><span><b>언어</b></span></td>
<td><span><b>특징</b></span></td>
</tr>
<tr>
<td><span>JAVA</span></td>
<td><br /><span>  ✔ 분산 네트워크 환경 적용 가능, 멀티스레드 기능 제공하므로 여러 작업 동시에 처리 가능<br />  ✔ 운영체제 및 하드웨어에 독립적, 이식성 강함<br />  ✔ 캡슐화 가능. 재사용성 높음</span><br /><br /></td>
</tr>
<tr>
<td><span>C++</span></td>
<td><br /><span>  ✔ C언어에 객체지향 개념을 적용한 언어</span><br /><span>  ✔ 모든 문제를 객체로 모델링하여 표현</span><br /><br /></td>
</tr>
<tr>
<td><span>Smalltalk</span></td>
<td><br /><span>  ✔ 1세대 객체지향 프로그래밍 언어 중 하나로 순수한 객체지향 프로그래밍 언어</span><br /><span>  ✔ 최초로 GUI 제공한 언어</span><br /><br /></td>
</tr>
</tbody>
</table>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><br />객체지향 프로그래밍 언어의 특징 <br />🧙&zwj;♂️ 캡슐화, 정보 은닉, 추상화, 상속성, 다형성 <br /><br />캡슐화(Encapsulation) <br />✔ 데이터(속성)과 데이터를 처리하는 함수를 하나로 묶는 것 <br />✔ 캡슐화된 객체의 세부 내용이 외부에 은폐엄폐(정보 은닉)되어 변경 발생시 오류 파급효과 적음<br />✔ 재사용 용이  <br /><br />정보 은닉(Information Hiding) <br />✔ 감기약을 예로 들면 정보 은닉은 감기약에 어떤 재료가 들어 있는지 몰라도<br />✔ 감기가 걸렸을 때 먹는 약이라는 것만 알고 복용하는 것과 같은 의미임 <br /><br />추상화(Abstraction)(ex. 2021 03) <br />✔ 불필요한 부분은 생략하고 객체 속성 중 가장 중요한 것만 중점을 두어 개략화하는 것(모델화)<br />✔ 데이터의 공통된 성질을 추출하여 슈퍼 클래스를 선정하는 개념<br />➡ 과정 추상화: 자세한 수행과정 정의하지 않고 전반적인 흐름만 파악할 수 있게 설계<br />➡ 데이터 추상화: 데이터 세부속성이나 용도를 정의하지 않고 데이터 구조를 대표할 수 있는 표현으로 대체 <br />➡ 제어 추상화: 이벤트 발생의 정확한 절차나 방법을 정의하지 않고, 대표할 수 있는 표현으로 대체 <br /><br /> 상속성(Inheritance) <br />✔ 이미 정의된 상위 클래스(부모 클래스)의 모든 속성을 하위 클래스가 물려받는 것 <br />✔ 하위 클래스는 상위 클래스의 모든 속성과 연산을 자신의 클래스 내에서 다시 정의하지 않고서도 즉시 자신의 속성으로 사용 가능<br />➡ 단일 상속: 하나의 상위 클래스로부터 상속받는 것 <br />➡ 다중 상속: 여러 개의 상위클래스로부터 상속받는 것</p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14">다형성(Polymorphism) <br />✔ 하나의 메시지에 대해 각 객체(클래스)가 가지고 있는 고유한 방법(특성)으로 응답할 수 있는 능력을 의미함<br />✔ 객체(클래스)들은 동일한 메소드명을 사용하며 같은 의미의 응답을 함 <br /><br />  <br />객체지향 기술(복습) <br />✔ 객체지향 분석(럼바우)(ex. 2021 02) <br />(1) 객체 모델링: 메소드 식별 <br />(2) 동적 모델링: 기능의 흐름 표시 <br />(3) 기능 모델링: 상세분석(제한사항, 성능 등) <br /><br />✔ 객체지향 분석 방법론 <br />(1) 럼바우(Rumbaugh): 객체, 동적, 기능 모형으로 분리하여 접근 <br />(2) 부치(Booch): 미시적(micro), 거시적(macro) 개발 프로세스로 접근 <br />(3) Coad&amp;Yourdon: E-R 다이어그램 사용하여 모델링 <br />(4) Jacobson: 시나리오 접근 <br />(5) Wirfs-Brocks: 설계의 연속적인 프로세스 <br /><br />신기술동향 <br />재해복구 시스템 <br />복구목표시간 (RTO, Recovery Time Objective) <br />재해로 인하여 서비스가 중단되었을 때, 서비스를 복구하는데까지 걸리는 최대 허용시간 <br />복구목표시점 (RPO, Recovery Point Objective)<span style="color: #ee2323;">(ex. 2020 02)</span> <br />재해로 인하여 중단된 서비스를 복구하였을 때, 유실을 감내할 수 있는 데이터의 손실 허용시점 <br />업무연속성계획 (BCP, Business Continuity Planning) <br />정보기술부문뿐 아니라, 인력-설비-자금 등 제반 자원을 대상으로 장애 및 재해를 포괄하여 조직의 생존을 보장하기 위한 예방 및 복구활동 등을 포함하는 보다 광범위한 계획 <br />재해복구계획 (DRP, Disaster Recovery Planning) <br />정보기술서비스기반에 대하여 재해가 발생하는 경우를 대비하여, 이의 빠른 복구를 통해 업무에 대한 영향을 최소화하기 위한 제반 계획 <br />재해복구시스템 (DRS, Disaster Recovery System) <br />재해복구계획의 원활한 수행을 지원하기 위하여 평상시에 확보하여 두는 인적-물적 자원 및 이들에 대한 지속적인 관리<br />현재 사용중인 전산 인프라를 운영하는 전산센터로써, 주전산센터 혹은 주사이트라 일컫기도 함. <br />재해복구 (DR, Disaster Recovery) <br />재해로 인하여 중단된 정보기술 서비스를 재개하는 것 <br /><br /></p>
<p data-ke-size="size14"><br />Linked Open Data ( LOD, 개방형 링크드 데이터)<span style="color: #ee2323;">(ex. 2020 02)</span> <br />웹에서 누구나 사용할 수 있도록 무료로 공개되는 연계 데이터.연계 데이터(Linked data)와 오픈 데이터(Open data)가 결합된 단어로, 웹에 게시되는 데이터에 식별자(URI)를 부여하고 관련 정보를 구조적으로 제공하는 연계 데이터를 저작권 없이 무료로 제공하여 사용자가 정보를 다양하고 효율적으로 활용할 수 있도록 한다. <br />애드 훅 네트워크 (Ad-hoc Network)<span style="color: #ee2323;">(ex. 2021 02)</span><br />: 재난 현장과 같이 별도의 고정된 유선망을 구축할 수 없는 장소에서 모바일 호스트만을 이용하여 구성한 네트워크. <br /> 망 구성 후 단기간 사용되거나 유선망 구성이 어려운 경우 사용. (빠른 망 구성, 저렴한 비용) <br /><br />◎ 빅데이터 (Big Data) <br />빅데이터는 기존의 관리 방법이나 분석 체계로는 처리하기 어려운 막대한 양의 정형 또는 비정형 데이터 집합 <br />스마트 단말의 빠른 확산, 소셜 네트워크 서비스의 활성화, 사물 네트워크의 확대로 데이터 폭발이 더욱 가속화 <br />- 빅데이터가 주목 받는 이유 : 기업이나 정부, 포털 등이 빅데이터를 효과적으로 분석함으로써 미래를 예측해 최적의 대응 방안을 찾고, 이를 수익으로 연결하여 새로운 가치를 창출하기 때문<br /><br />◎ 브로드 데이터 (Broad Data)<br />브로드 데이터는 다양한 채널에서 소비자와 상호 작용을 통해 생선되느 기업 마케팅에 있어 효율적이고 다양한 데이터<br />이전에 사용하지 않거나 알지 못했던 새로운 데이터나, 기존 데이터에 새로운 가치가 더해진 데이터 <br />- 다양한 정보를 뜻함 (소비자의 SNS 활동이나 위치 정보 등) <br /><br /> ◎ 메타 데이터 (Meta Data)<br />일련의 데이터를 정의하고 설명해 주는 데이터.<br />컴퓨터에서는 데이터 사전의 내용, 스키마 등을 의미 <br />HTML문서에서는 메타 태그 내의 내용이 메타 데이터<br />- 메타 데이터는 여러 용도로 사용되나 주로 빠르게 검색하거나 내용을 간략하고 체계적으로 하기 위해 사용 <br /><br /> ◎ 디지털 아카이빙 (Digital Archiving) <br />디지텅 아카이빙은 다지털 정보 자원을 장기적으로 보존하기 위한 작업 <br />아날로그 콘텐츠는 디지털로 변환한 후 압축하여 저장하고, 디지털 콘텐츠도 체계적으로 분류하고 메타 데이터를 만들어 DB화하는 작업 <br />- 디지털 아카이빙은 늘어나는 정보 자원의 효율적인 관리와 이용을 위해 필요한 작업<br /><br />◎ 하둡 (Hadoop)<span style="color: #ee2323;">(ex. 2020 04)</span><br />하둡은 오픈 소스를 기반으로 한 분산 컴퓨팅 플랫폼</p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14">7장 SQL 응용</p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14">◆ 트랜잭션(Transaction): 인가받지 않은 사용자로부터 데이터를 보장하기 위해 DBMS가 가져야 하는 특성, 하나의 논리적 기능을 정상적으로 수행하기 위한 작업의 기본 단위</p>
<p data-ke-size="size14">◆ 트랜잭션 특성<span style="color: #ee2323;">(ACID)</span></p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>원자성(Atomicity): 트랜잭션의 연산 전체가 성공 또는 실패되어야 하는 성질 (All or Nothing)</li>
<li>일관성(Consistency): 트랜잭션 수행 전과 트랜잭션 수행 완료 후의 상태가 같아야 하는 성질</li>
<li>격리성(Isolation): 동시에 실행되는 트랜잭션들이 서로 영향을 미치지 않어야 한다는 성질</li>
<li>영속성(Durability): 성공이 완료된 트랜잭션의 결과는 영속적으로 데이터베이스에 저장되어야 하는 성질</li>
</ul>
<p data-ke-size="size14">◆ 트랜잭션 제어어(TCL, Transaction Control Language): 트랜잭션의 결과를 허용하거나 취소하는 목적으로 사용되는 언어</p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>TCL 명령어<span style="color: #ee2323;">(커롤체)</span>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>COMMIT: 트랜잭션을 메모리에 영구적으로 저장하는명령어</li>
<li>ROLLBACK: 트랜잭션 내역의 저장을 무효화시키는 명령어</li>
<li>CHECKPOINT(SAVEPOINT): ROLLBACK을 위한 시점을 지정하는 명령어</li>
</ul>
</li>
</ul>
<p data-ke-size="size14">◆ 데이터 정의어(DDL: Data Definition Language): DB를 구축하거나 수정할 목적으로 사용하는 언어</p>
<p data-ke-size="size14">◆ DDL 대상<span style="color: #ee2323;">(도스테뷰인)</span></p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>도메인(Domain): 하나의 속성이 가질 수 있는 원자값들의 집합</li>
<li>스키마(Schema): 데이터베이스의 구조, 제약조건 등의 정보를 담고 있는 기본적인 구조
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>외부 스키마, 개념 스키마, 내부 스키마</li>
</ul>
</li>
<li>테이블(Table): 데이터 저장 공간</li>
<li>뷰(View): 하나 이상의 물리 테이블에서 유도되는 가상의 테이블</li>
<li>인덱스(Index): 검색을 빠르게 하기 위한 데이터 구조</li>
</ul>
<p data-ke-size="size14">◆ DDL 명령어<span style="color: #ee2323;">(크알드트)</span>: CREATE(생성), ALTER(수정), DROP(삭제),TRUNCATE</p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>CASCADE: 제거할 요소를 참조하는 다른 모든 개체를 함께 제거</li>
<li>RESTRICT: 다른 개체가 제거할 요소를 참조중일 떄는 제거를 취소</li>
</ul>
<p data-ke-size="size14">◆ 데이터 조작어(DML: Data Manipulation Language): 저장된 데이터를 실질적으로 관리하는데 사용되는 언어</p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>DML 유형<span style="color: #ee2323;">(세인업데)</span>: SELECT(조회), INSERT(삽입), UPDATE(수정), DELETE(삭제)</li>
</ul>
<p data-ke-size="size14"><span style="color: #ee2323;">(셀프 웨 구해오)</span><span> </span>SELECT 명령문 -SELECT / FROM / WHERE / GROUP BY / HAVING / ORDER BY </p>
<p data-ke-size="size14">◆ 데이터 제어어(DCL: Data Control Language): 데이터의 보안, 무결성, 회복, 병행 제어등을 정의하는데 사용하는 언어</p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>DCL 유형
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>GRANT: 사용 권한 부여</li>
<li>REVOKE: 사용 권한 취소</li>
</ul>
</li>
</ul>
<p data-ke-size="size14"><span style="color: #ee2323;">그온투</span><span> </span>GRANT 명령어 GRANT 권한 ON 테이블 TO 사용자</p>
<p data-ke-size="size14"><span style="color: #ee2323;">리온프</span><span> </span>REVOKE 명령어 REVOKE 권한 ON 테이블 FROM 사용자</p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14">▶ 병행제어(Concurrency Control) - 일관성 주요 기법<br />다수 사용자 환경에서 여러 트랜잭션을 수행할 때, 데이터베이스의 일관성 유지를 위해 상호작용을 제어하는 기법 <br /><br />▶ 병행제어 기법 종류<span style="color: #ee2323;">(ex. 2021 02)</span><br />⦁  로킹(Locking) : 일관성과 무결성을 유지하기 위한 트랜잭션의 순차적 진행을 보장하는 직렬화 기법<br />⦁  낙관적 검증 : 일단 트랜잭션을 수행하고, 트랜잭션 종료 시 검증을 수행<br />⦁  타임 스탬프 순서 : 타임 스탬프를 부여해 부여된 시간에 따라 트랜잭션 수행 <br />⦁  다중버전 동시성 제어(MVCC) : 타임스탬프를 비교해 직렬가능성이 보장되는 적절한 버전을 선택해 접근하도록 함</p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><b><span><span><b>* 형상 관리(SCM; Software Configuration Management)<span> </span><span style="color: #ee2323;"><b>(2020 실기 2회 기출문제 - 단답형)</b></span></b></span></span></b></p>
<p id="SE-dda46d43-146e-40e3-a9ce-8140251fb715" data-ke-size="size14"><span>- 소프트웨어의 개발 과정에서<b><span> </span></b><span style="color: #ee2323;"><b>소프트웨어의 변경 사항을 관리하기 위해 개발된 일련의 활동</b></span></span></p>
<p id="SE-a245af3b-6ddf-4d83-985e-12fa1e3ec1dd" data-ke-size="size14"><span>- 소프트웨어 변경의 원인을 알아내고 제어하며, 적절히 변경되고 있는지 확인하여 해당 담당자에게 통보</span></p>
<p id="SE-f2b44561-6f4e-4223-8c56-851b559de1d0" data-ke-size="size14"><span>- 형상 관리는 소프트웨어<span> </span><span style="color: #ee2323;"><b>개발의 전 단계에 적용되는 활동</b></span>이며, 유지보수 단계에서도 수행</span></p>
<p id="SE-398a70a0-435b-4827-9e00-95f3c5f7efd2" data-ke-size="size14"><span>- 형상 관리는 소프트웨어 개발의 전체 비용을 줄이고, 개발 과정의 여러 방해 요인이 최소화되도록 보증하는 것을 목적으로 함</span></p>
<p data-ke-size="size14"> </p>
<p id="SE-f4e34807-f81f-4f46-9535-40bf9d3946b0" data-ke-size="size14"><span><b>* 형상 관리 기능의 종류<span> </span></b></span><span><b>:<span> </span></b><span style="color: #ee2323;"><b>형상 식별, 버전 제어, 형상 통제, 형상 감사, 형상 기록(식통감기)</b></span></span></p>
<p id="SE-6cbdc1d7-d201-47ce-a699-13e31ad6f18b" data-ke-size="size14"><span>-<span> </span><b>형상 식별</b></span></p>
<p id="SE-6fef6633-23bf-4a60-866f-bbbc7dcfa9e5" data-ke-size="size14"><span>: 형상 관리 대상에 이름과 관리 번호를 부여하고,<span> </span><span style="color: #ee2323;"><b>계층(Tree) 구조로 구분</b></span>하여 수정 및 추적이 용이하도록 함</span></p>
<p id="SE-231e5343-60b6-4d56-8996-59f552f46c82" data-ke-size="size14"><span><b>- 버전 제어</b></span></p>
<p id="SE-20cf7e9b-34ef-4e7f-aca3-e36aa68f14f8" data-ke-size="size14"><span>: 소프트웨어 업그레이드나 유지 보수 과정에서 생성된 다른 버전의 형상 항목을 관리하고,<span> </span></span><span>이를 위해<span> </span><span style="color: #ee2323;"><b>특정 절차와 도구(Tool)를 결합</b></span>시키는 작업</span></p>
<p id="SE-f42c7df3-9b8e-4ee7-b6a6-3d1b618e7064" data-ke-size="size14"><span>-<span> </span><b>형상 통제(변경 관리)</b></span></p>
<p id="SE-ee889732-8e64-4a0b-87e5-075c850ca74b" data-ke-size="size14"><span>: 식별된 형상 항목에 대한 변경 요구를 검토하여<span style="color: #ee2323;"><b><span> </span>현재의 기준선(Base Line)이 잘 반영될 수 있도록 조정</b></span>하는 작업</span></p>
<p id="SE-9e48e265-add7-4547-bf3a-28e8b6287ba7" data-ke-size="size14"><span>-<span> </span><b>형상 감사</b></span></p>
<p id="SE-6c77f1cc-0729-4177-ac54-276483f970bb" data-ke-size="size14"><span>: 기준선의<b><span style="color: #ee2323;"><span> </span>무결성을 평가하기 위해</span><span> </span>확인, 검증, 검열 과정을 통해 공식적으로 승인</b>하는 작업</span></p>
<p id="SE-9a4ab07d-18c1-4654-81da-a8bcbbe5690a" data-ke-size="size14"><span>-<b><span> </span>형상 기록(상태 보고)</b></span></p>
<p id="SE-2c954ec9-a214-4361-80ac-870079936667" data-ke-size="size14"><span>: 형상의 식별, 통제, 감사 작업의 결과를 기록 관리하고 보고서를 작성하는 작업</span></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><span>* 베이스라인(단답형) : 개발 과정의 각 단계에서 나온 산출물들의 변화를 통제하는 시점</span></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><span style="color: #ee2323;"><b><span><span>* 결합도와 응집도</span></span></b></span></p>
<p data-ke-size="size14"><span><span>- 결합도 : 상호의존의 정도, <span style="color: #ee2323;"><b>결합도가 약해야 품질이 상승</b></span></span></span></p>
<p id="SE-aa887fd7-4857-4a91-9c27-382ec35824b5" data-ke-size="size14"><span><b>[ 결합도가 약한 순서 -&gt; 강한 순서 ]</b></span></p>
<p id="SE-3abad6ca-2f39-452b-85af-2d064498bb58" data-ke-size="size14"><span style="color: #ee2323;"><b>data &ndash; stamp &ndash; control &ndash; external &ndash; common - content</b></span></p>
<p id="SE-3ad13f4b-b303-4386-9bfb-381b20156b1e" data-ke-size="size14"><span style="color: #ee2323;"><b>자스</b><b>(잤으)니까 합격</b><b>제외</b><b> </b><b>공</b><b>부는 나(</b><b>내</b><b>)처럼(내공외제스자)</b></span></p>
<p data-ke-size="size14"><span><span style="color: #ee2323;"><b><span>자료-데이터 / 스탬프-자료구조 / 제어-다른 모듈에서 흐름 파악 / 외부-참조 </span></b></span><span style="color: #ee2323;"><b><span>/</span></b></span><span style="color: #ee2323;"><b><span> 공통-공유되는 / 내용-직접참조,다른모듈에서 사용</span></b></span></span></p>
<p id="SE-eb9d8c48-8769-469b-968a-8bf02b7be4ad" data-ke-size="size14"><span>- 자료: 어떤 모듈이 다른 모듈을 호출하면서 매개 변수나 인수로 데이터를 넘겨주고, 호출 받은 모듈은 받은 <b>데이터</b>에 대한 처리 결과를 다시 돌려주는 방식</span></p>
<p id="SE-bc31182c-b36c-49c8-bea9-31210b9613a6" data-ke-size="size14"><span>- 스탬프: 두 모듈이 동일한 <b>자료 구조</b>를 조회하는 경우</span></p>
<p id="SE-a8cc1e4b-7d5d-40a4-b34f-14588b409fd1" data-ke-size="size14"><span>- 제어: 한 모듈이 다른 모듈의 상세한 처리 절차를 알고 있어 이를 통제하는 경우나 처리 기능이 두 모듈에 분리되어 설계된 경우, <b>다른 모듈에서 흐름을 제어</b></span></p>
<p id="SE-1e5cd432-c3bb-41d7-a251-a0521864997c" data-ke-size="size14"><span>- 외부: 어떤 모듈에서 선언한 데이터를 <b>외부의 다른 모듈에서 참조</b>할 때</span></p>
<p id="SE-98158344-fb2e-43b5-a0a6-2a4cfe535f56" data-ke-size="size14"><span>- 공통: <b>공유되는 공통 데이터 영역</b>을 여러 모듈이 사용할 때</span></p>
<p id="SE-07a7d11e-1fde-4c58-b063-a76b0d8fc088" data-ke-size="size14"><span>- 내용: 한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 <b>직접 참조하거나 수정</b>할 때</span></p>
<p id="SE-fa00c622-ad28-4b58-83c3-14cf827067ca" data-ke-size="size14"><span>( 다른 모듈에서 사용하는 경우 )</span></p>
<p id="SE-1fd2f898-008a-47e3-80ad-489327322754" data-ke-size="size14"> </p>
<p id="SE-e32aa3de-6114-45a3-a387-c125aa6be313" data-ke-size="size14"><span>- 응집도 : 정보은닉 개념 확장, <b><span style="color: #ee2323;">응집도가 강할수록 품질이 좋음</span></b></span></p>
<p id="SE-177eca69-52e5-4212-9e30-34b0ce28d227" data-ke-size="size14"><span><b>[ 응집도가 강한 순서 -&gt; 약한 순서]</b></span></p>
<p id="SE-65a08c5c-5fd4-41f2-9b22-89212ad03609" data-ke-size="size14"><span style="color: #ee2323;"><b>functional &ndash; sequential &ndash; communication &ndash; procedural &ndash; temporal &ndash; logical &ndash; coincidental</b></span></p>
<p id="SE-f61b2d8f-adfd-47a3-a71c-a1fdf10e7e7e" data-ke-size="size14"><span><span style="color: #ee2323;"><b>기</b></span><b>엽고 </b><span style="color: #ee2323;"><b>순</b></span><b>진한 </b><span style="color: #ee2323;"><b>교</b></span><b>회오빠는 </b><span style="color: #ee2323;"><b>절</b></span><b>은 </b><span style="color: #ee2323;"><b>시</b></span><b>러 </b><span style="color: #ee2323;"><b>노우(우논시절통순기)</b></span></span></p>
<p data-ke-size="size14"><span><b>기능-단일 / 순차-나온것 입력으로 / 통신-동일한입출력 다른기능수행</b></span></p>
<p data-ke-size="size14"><span><b>절차-다수의 관련기능 순차수행 / 시간-특정시간 / 논리-유사한 성격 / 우연-서로 관련 없는 요소</b></span></p>
<p id="SE-aa289403-ac80-4682-9e1c-8fe587e362a4" data-ke-size="size14"><span>- 기능적 : 모듈 내부의 모든 기능 요소들이 <b>단일</b> 문제와 연관되어 수행될 경우</span></p>
<p id="SE-5751bfee-cd9b-4678-9da5-9053bd901dc7" data-ke-size="size14"><span>- 순차적 : 모듈 내 하나의 활동으로부터 <b>나온 출력 데이터를 그 다음활동의 입력 데이터로 사용</b>할 경우</span></p>
<p id="SE-2f2451c1-2e72-4148-83f8-b45664a536ec" data-ke-size="size14"><span>- 통신적(교환적) : <b>동일한 입출력을 사용하여 서로 다른 기능을 수행</b>하는 구성 요소들이 모였을 경우</span></p>
<p id="SE-3cf9c30f-740e-4e18-b431-2e1e953cc6c1" data-ke-size="size14"><span>- 절차적 : 모듈이<b> 다수</b>의 관련 기능을 가질 때 모듈 안의 구성요소들이 그 기능을 <b>순차적</b>으로 수행할 경우</span></p>
<p id="SE-2d3e8c08-a908-4134-b9ee-870855e0e2bc" data-ke-size="size14"><span>- 시간적 : <b>특정 시간에 처리</b>되는 몇 개의 기능을 모아 하나의 모듈로 작성한 경우</span></p>
<p id="SE-ef21cd21-7d35-492b-9e44-b98c9589bbb2" data-ke-size="size14"><span>- 논리적 :<b> 유사한 성격</b>을 갖거나 특정 형태로 분류되는 처리요소들이 하나의 모듈이 되는 경우</span></p>
<p id="SE-d54c9a91-b0c3-4dfe-ab20-6c07abb43185" data-ke-size="size14"><span>- 우연적 : 모듈 내부의 각 구성요소들이 <b>서로 관련 없는 요소</b>로만 구성된 경우</span></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><span> <br /> 팬인(Fan-In) / 팬아웃(Fan-Out)<span style="color: #ee2323;">(ex. 2020 01)</span></span></p>
<p data-ke-size="size14"><span><span style="color: #ee2323;">- 소프트웨어의 구성 요소인 모듈을 계층적으로 분석하기 위해서 팬 인, 팬 아웃 활용 <br />- 팬 인 : 어떤 모듈을 제어하는 수, 해당 모듈로 들어오는 모듈의 수 (능동태 느낌)<br />- 팬 아웃 : 어떤 모듈에 의해 제어되는 수, 해당 모듈에서 나가는 모듈의 수 (수동태 느낌)</span><br />- 팬인과 팬아웃을 분석해 시스템의 복잡도를 알 수 있음 <br />- 팬인이 높다 = 재사용 측면에서 설계가 잘되었으나, 단일 장애점이 발생할 수 있으므로 중점적인 관리 및 테스트가 필요하다 <br />- 팬아웃이 높다 = 불필요한 호출을 하고 있는지 검토하고, 단순화 시킬 수 있는지 여부에 대한 검토가 필요하다 <br />- 시스템의 복잡도를 최적화하기 위해선 팬인은 높게, 팬아웃은  낮게 설계해야 함</span></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14">◆ SW 개발 보안: 소프트웨어 개발 과정에서 지켜야 할 일련의 보안 활동</p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>SW 개발 보안 생명주기<span style="color: #ee2323;">(요설구테유)</span>: 요구사항 명세 &rarr; 설계 &rarr; 구현 &rarr; 테스트 &rarr; 유지보수</li>
</ul>
<p data-ke-size="size14">◆ SW 개발 보안 3대 요소<span style="color: #ee2323;">(기무가)</span></p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>기밀성(Confidentiality): 시스템 내의 정보와 자원은 인가된 사용자에게만 접근이 허용</li>
<li>무결성(Integrity): 시스템 내의 정보는 오직 인가된 사용자만 수정할 수 있음</li>
<li>가용성(Availability): 인가받은 사용자는 시스템 내의 정보와 자원을 언제라도 사용할 수 있음</li>
</ul>
<p data-ke-size="size14">◆ DoS(Denial of Service) 공격: 시스템을 악의적으로 공객해서 해당 시스템의 자원을 부족하게 하여 원래 의도된 용도로 사용하지 못하게 하는 공격</p>
<p data-ke-size="size14">◆ DoS 공격의 종류</p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>SYN 플러딩(SYN Flooding): 서버의 동시 가용 사용자수를 SYN 패킷만 보내 점유하여 다른 사용자가 서버를 사용 불가능하게 하는 공격</li>
<li>UDP 플러딩(UDP Flooding): 대량의 UDP 패킷을 만들어 임의의 포트 번호로 전송하여 응답 메시지를 생성하게 하여 지속해서 자원을 고갈시키는 공격</li>
<li>스퍼프(Smurf)/스머핑(Smurfing): 출발지 주소를 대상의 IP로 설정하여 네트워크 전체에게 ICMP Echo패킷을 직접 브로드캐스팅하여 마비시키는 공격</li>
<li>죽음의 핑(PoD: Ping of Death): ICMP 패킷을 정상적인 크기보다 아주 크게 만들어 전송하여 정상적인 서비스를 못하도록 하는 공격</li>
<li>랜드 어택(Land Attack): 출발지 IP와 목적지 IP를 같은 패킷 주소로 만들어 보내 시스템의 가용성을 침해하는 공격</li>
<li>티어 드롭(Tear Drop): IP패킷의 재조합 과정에서 잘못된 정보로 인해 수신 시스템이 문제를 발생하도록 만드는 공격</li>
<li>봉크(Bonk)/보잉크(Boink): 프로토콜의 오류 제어를 이용한 공격기법</li>
</ul>
<p data-ke-size="size14">◆ DDoS(Distributed Denial of Service): 여러 대의 공격자를 분산 배치하여 동시에 동작하게함으로써 특정 사이트를 공격하는 기법</p>
<p data-ke-size="size14">◆ DDos 공격도구</p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>Trinoo: 많은 소스로부터 통합된 UDP flood 서비스 거부 공격을 유발하는 데 사용되는 도구</li>
<li>Tribe Flood Network: 많은 소스에서 하나 혹은 여러개의 목표 시스템에 대해 서비스 거부 공격을 수행할 수 있는 도구</li>
<li>Stacheldraht: 분산 서비스 거부 에이전트 역할을 하는 Linux 및 Solaris 시스템용 멀웨어 도구</li>
</ul>
<p data-ke-size="size14">◆ DoS와 DDoS 차이</p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>DoS는 직접 공격, DDoS는 공격하도록 지시</li>
<li>DoS는 한 사람에 의해 공격을 감행, DDoS는 수많은 감염 호스트를 통해 공격을 감행</li>
</ul>
<p data-ke-size="size14">◆ DRDoS(Distributed Reflection DoS): 공격자는 출발지 IP를 공격대상 IP로 위조하여 다수의 반사 서버로 요청 정보를 전송, 공격 대상자는 반사 서버로부터 다량의 응답을 받아서 서비스 거부(DoS)가 되는 공격</p>
<p data-ke-size="size14">◆ 세션 하이재킹(Session Hijacking): TCP의 세션 관리 취약점을 이용한 공격 기법, 케빈 미트닉이 사용</p>
<p data-ke-size="size14">◆ 애플리케이션 공격기법</p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>HTTP GET 플러딩: 과도한 Get 메시지를 이용하여 웹 서버의 과부하를 유발시키는 공격</li>
<li>Slowloris: HTTP GET 메서드를 사용하여 헤더의 최종 끝을 알리는 개행 문자열을 전송하지 않고, 대상 웹 서버와 연결상태를 장시간 지속시키고 연결자원을 모두 소진시키는 서비스 거부 공격</li>
<li>RUDY: 요청 헤더의 Content-Length를 비상장으로 크게 설정하여 메시지 바디 부분을 매우 소량으로 보내 계속 연결상태를 유지시키는 공격</li>
<li>Slow HTTP Read DoS: 다수 HTTP 패킷을 지속적으로 전송하여 웹서버의 연결상태가 장시간 지속, 연결자원을 소진시키는 서비스 거부 공격</li>
<li>Hulk DoS: 공격자가 웹 페이지 주소를 지속적으로 변경하면서 다량으로 GET요청을 발생시키는 서비스 거부 공격</li>
<li>Hash DoS: 많은 수의 파라미터를 POST방식으로 웹서버로 전달하여 다수의 해시 출돌을 발생시켜서 자원을 소모시키는 서비스 거부 공격</li>
</ul>
<p data-ke-size="size14">◆ 네트워크 공격</p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>스니핑: 공격대상의 데이터만 몰래 들여다보는 수동적 공격 기법</li>
<li>네트워크 스캐너, 스니퍼: 네트워크 하드웨어 및 소프트웨어 구성의 취약점 파악을 위해 공격자가 취약점을 탐색하는 공격 도구</li>
<li>패스워드 크래킹
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>사전 크래킹: ID와PW가 될 가능성이 있는 단어를 파일로 만들어 파일의 단어를 대입하여 크랙하는 공격 기법</li>
<li>무차별 크래킹: 무작위로 패스워드 자리에 대입하여 패스워드를 알아내는 공격 기법</li>
<li>패스워드 하이브리드 공격: 사전공격+무차별공격</li>
<li>레인보우 테이블 공격: 크래킹 하고자 하는 해시 값을 테이블에서 검색해서 역으로 패스워드를 찾는 공격 기법</li>
</ul>
</li>
<li>IP 스푸핑: 침입자가 인증된 컴퓨팅 시스템인 것처럼 속여서 인증된 호스트의 IP 주소로 위조하여 타깃에 정송하는 공격 기법</li>
<li>ARP 스푸핑: 공격자가 특정 호스트의 MAC 주소를 자신의 MAC 주소로 위조한 ARP Reply를 만들어 희생자에게 지속적으로 전송</li>
<li>ICMP Redirect 공격: 스니핑 시스템을 네트워크에 존재하는 또다른 라우터라고 알림으로써 패킷의 흐름을 바꾸는 공격 기법</li>
<li>트로이 목마: 악성 루틴이 숨어있는 프로그램, 실행하면 악성 코드를 실행</li>
</ul>
<p data-ke-size="size14">◆ 버퍼 오버플로우(Buffer Overflow) 공격: 메모리에 할당도니 버퍼 크기를 초과하는 양의 데이터를 입력하여 프로세스의 흐름을 변경시켜서 악성 코드를 실행 시키는 공격 기법</p>
<p data-ke-size="size14">◆ 백도어(Backdoor): 허가받지 않고 시스템에 접속하는 권리, 정상적인 인증 절차를 우회하는 기법</p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14">◆ 서버 인증의 기능: 스니핑 방지(SSL인증서 설치), 피싱 방지, 데이터 변조 방지, 기업 신뢰도 향상(기업 인증)</p>
<p data-ke-size="size14">◆ 인증 기술의 유형<span style="color: #ee2323;">(지소생특)</span></p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>지식기반 인증: 사용자가 기억하고 있는 지식 (ID/PW)</li>
<li>소지기반 인증: 소지하고 있는 사용자 물품 (공인인증서, OTP)</li>
<li>생체기반 인증: 고유한 사용자의 생체 정보 (홍채, 얼굴, 지문)</li>
<li>특정기반 인증: 사용자의 특징을 활용 (서명, 몸짓)</li>
</ul>
<p data-ke-size="size14">◆ 접근 통제 기법</p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>식별(Identification): 자신이 누구라고 시스템에 밝히는 행위</li>
<li>인증(Authentication): 주체의 신원을 검증하기 위한 활동</li>
<li>인가(Authorization): 인증된 주체에게 접근을 허용하는 활동</li>
<li>책임추적성(Accountability): 주체의 접근을 추적하고 행동을 기록하는 활동</li>
</ul>
<p data-ke-size="size14">◆ 서버 접근 통제 유형</p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>임의적 접근 통제(DAC): 신분에 근거하여 객체에 대한 접근을 제한하는 방법</li>
<li>강제적 접근 통제(MAC): 주체가 갖는 접근 허가 권한에 근거하여 객체에 대한 접근을 제한하는 방법</li>
<li>역할 기반 접근 통제(RBAC): 중앙 관리자가 조직 내 맡은 역할에 기초하여 자원에 대한 접근을 제한하는 방법</li>
</ul>
<p data-ke-size="size14">◆ 암호 알고리즘(Encryption Algorithm): 데이터의 무결성 및 기밀성 확보를 위해 정보를 쉽게 해독할 수 없는 형태로 변환하는 기법</p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>양방향 방식: 대칭 키 암호 방식, 비대칭 키 암호 방식</li>
<li>일방향 해시함수 방식: MDC, MAC</li>
</ul>
<p data-ke-size="size14">◆ 대칭 키 암호 방식: 암호화와 복호화에 같은 암호 키를 쓰는 알고리즘</p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>블록 암호 방식: 고정 길이의 블록을 암호화하여 반복하는 알고리즘(EDS, AES, SEED)</li>
<li>스트림 암호 방식: 매우긴 주기의 난수열을 발새이켜 평문과 더불어 암호문을 생성하는 방식(RC4)</li>
</ul>
<p data-ke-size="size14">◆ 비대칭 키 암호 방식: 개인 키를 나눠 가지지 않은 사용자들이 안전하게 통신하는 방식, 공개키는 누구나 알수 있으나 개인키는 키의 소유자만 알고 있어야 한다. (RSA, 디피-헬만)</p>
<p data-ke-size="size14">◆ 일방향 암호 방식(해시 암호 방식): 임의 길이의 정보를 입력받아, 고정된 길이의 암호문(해시값)을 출력하는 암호 방식</p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>MAC: 키를 사용하는 메시지 인증 코드로 메시지의 무결성과 송신자의 인증 보장</li>
<li>MDC: 키를 사용하지 않는 변경 감지 코드로 메시지의 무결성 보장</li>
</ul>
<p data-ke-size="size14">◆ 대칭키 암호화 알고리즘</p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>DES: 1975년 IBM 개발, 대칭 키 기반</li>
<li>SEED: 1999년 한국인터넷진흥원(KISA) 개발</li>
<li>AES: 2001년 미국 표준기술 연구소(NIST) 개발</li>
<li>ARIA: 2004년 국가정보원과 산학연구협회가 개발</li>
<li> </li>
<li>IDEA: DES 대체, 스위스 연방기술기관 개발</li>
<li>LFSR: 선형함수로 계산되는 구조로 되어있는 스트임 암호화 알고리즘</li>
</ul>
<p data-ke-size="size14">◆ 비대칭 키 암호화 알고리즘</p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>디피-헬만: 최초의 공개키 알고리즘</li>
<li>RSA: 1977년 MIT 개발</li>
<li>ElGamal: 1984년 ElGamal 개발</li>
<li>ECC: 1985년 RSA 대안으로 개발</li>
</ul>
<p data-ke-size="size14">◆ 해시 암호화 알고리즘</p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>MD5: MD4 개선한 암호화 알고리즘, 파일의 무결성 검사에 사용</li>
<li>SHA-1: 1993년 NSA에 미국 정부 표준 지정</li>
<li>SHA-256/384/512: 256비트의 해시값을 생성하는 해시함수</li>
<li>HAS-160: 국내 표준 서명 알고리즘</li>
<li>HAVAL: 메시지를 1024bits 블록으로 나눔</li>
</ul>
<p data-ke-size="size14">◆ IPSec(Internet Protocol Security): 무결성과 인증을 보장하는 인증 헤더와 기밀성을 보장하는 암호화를 이용한 IP 보안 프로토콜</p>
<p data-ke-size="size14">◆ SSL(Secure Socket Layer)/TLS(Transport Layer Security): 클라이언트와 서버간의 웹데이터 암호화(기밀성), 상호 인증 및 전송 시 데이터 무결성을 보장하는 보안 프로토콜</p>
<p data-ke-size="size14">◆ S-HTTP(Secure Hypertexrt Transfer Protocol): 웹상에서 네트워크 트래픽을 암호화 하는 방법</p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14">10장 애플리케이션 테스트 관리</p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><span><b>1.  애플리케이션 테스트 관리</b></span></p>
<p data-ke-size="size14"><span><b>1) 애플리케이션 테스트</b></span></p>
<p data-ke-size="size14"><span><b>* 소프트웨어 테스트</b></span></p>
<p data-ke-size="size14"><span>- 개발된 응용프로그램이나 시스템이 사용자가 요구하는 성능이나 사용성, 안정성 등을 만족하는지 확인하고 소프트웨어 결함을 찾아내는 과정</span></p>
<p data-ke-size="size14"><span>- 오류 발견의 관점, 오류 예방의 관점, 품질 향상 관점<span style="color: #ee2323;">(발예향)</span></span></p>
<p data-ke-size="size14"><b><span>* 테스트 프로세스 : 테스트 계획 -&gt; 분석/설계 -&gt; 수행 -&gt; 관리</span></b></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><b><span>* 소프트웨어 테스트 원리</span></b></p>
<p data-ke-size="size14"><span>- 테스팅은 결함이 존재하는 것을 밝혀내는 행동</span></p>
<p data-ke-size="size14"><span>- 완벽한 테스팅은 없다.</span></p>
<p data-ke-size="size14"><span>- 개발 초기에 테스팅을 시작 ( 개발 완료 후 테스팅을 시작하면 비용 및 시간 증가 )</span></p>
<p data-ke-size="size14"><span>- 결함의 집중 ( 결함은 한 모듈에 집중되어 있다 )</span></p>
<p data-ke-size="size14"><b><span>- 살충제 패러독스 ( 2020 실기 1회 기출문제 )</span></b></p>
<p data-ke-size="size14"><b><span>:<span> </span><span style="color: #ee2323;">동일</span>한 테스트 케이스로 테스트를 진행하면<span> </span><span style="color: #ee2323;">더이상 새로운 결함을 찾을 수 없으므로</span><span> </span><span style="color: #ee2323;">주기적으로 테스트 케이스를 점검하고 관리</span>하여야 한다.</span></b></p>
<p data-ke-size="size14"><span>- 테스팅은 정황에 의존적</span></p>
<p data-ke-size="size14"><b><span>- 오류-부재의 궤변(서술형)</span></b></p>
<p data-ke-size="size14"><b><span>: 요구사항을 충족시켜주지 못한다면,<span> </span><span style="color: #ee2323;">결함이 없다고 해도 품질이 높다고 볼 수 없는</span><span> </span>소프트웨어 테스트 원리</span></b></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><span style="color: #ee2323;">(결완초집 살정오)</span><span> </span>소프트웨어 테스트의 원리 - 결함이 존재 / 완벽한 테스팅 불가능 / 초기에 테스팅 시작 / 결함집중 / 살충제 패 러독스 / 정황에 의존 / 오류-부재의 궤변</p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><b><span>* 소프트웨어 테스트 산출물</span></b></p>
<p data-ke-size="size14"><span>- 테스트 계획서(테스트 수행 계획), 테스트 케이스(테스트 항목 명세서, 설계 산출물), 테스트 시나리오(테스트 절차 명세), 테스트 결과서(테스트 리프팅)</span></p>
<p data-ke-size="size14"><span><b>- 정적 테스트 :</b><span> </span><b>프로그램 실행 없이 구조를 분석</b>하여 논리성을 검증 ( 동료검토, 인스펙션, 워크스루 )</span></p>
<p data-ke-size="size14"><span><b>- 동적 테스트 :</b><span> </span><b>프로그램 실행을 요구</b>하는 테스트 ( 화이트박스, 블랙박스 테스트 )</span></p>
<p data-ke-size="size14"> </p>
<p id="SE-0548b64e-6412-43c6-a50a-0b37f1149329" data-ke-size="size14"><span>* 종류</span></p>
<p id="SE-154cd7f2-7025-40be-9427-06dfa4f61c27" data-ke-size="size14"><span>- <b>동료 검토(Peer Review)</b> : 요구사항 명세서 작성자가 <b>내용을 직접 설명, <span style="color: #ee2323;">동료</span>들이 이를 들으면서</b> 결함 발견</span></p>
<p id="SE-ed10c9b4-2433-45c3-99ff-2448bf204c82" data-ke-size="size14"><span>- <b>워크 스루(Walk Trough)</b> : 검토 회의 전 요구사항 명세서를 <b><span style="color: #ee2323;">미리 배포</span>하여 사전 검토 회의</b>를 통해 결함 발견</span></p>
<p id="SE-26b58d34-a2ac-4f18-ab74-858ed31011ab" data-ke-size="size14"><span>- <b>인스펙션(Inspection)</b> : 요구사항 명세서 <b>작성자를 제외한<span style="color: #ee2323;"> 다른 검토 전문가</span>들이 결함 발견</b></span></p>
<p id="SE-88438a28-d83e-4ec4-b1f7-6a6e81dd36d1" data-ke-size="size14"><span>- <b>프로토타이핑</b> : 실제 개발될 소프트웨어에 대한 ​<span style="color: #ee2323;"><b>견본품</b></span>을 만들어 최종 결과물 예측</span></p>
<p id="SE-654be2aa-e1d4-4ecf-add1-2b6e86218721" data-ke-size="size14"><span>- <b>테스트 설계</b> : <b>테스트 케이스를 생성</b>해 이후에 요구사항이 현실적으로 테스트 가능한지 검토</span></p>
<p id="SE-b5e80cd9-0422-4bfe-873b-bd570e997900" data-ke-size="size14"><span>- CASE 도구 활용 : 일관성 분석을 통해 요구사항 변경사항의 추적 및 분석, 관리, 표준 준수 여부 확인</span></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><span style="color: #ee2323;"><span>◆ 화이트박스 테스트(White-Box Test): 원시 코드의 논리적인 모든 경로를 테스트하여 테스트 케이스를 설계하는 방법 (구조 검사)</span></span></p>
<p data-ke-size="size14">◆ 화이트박스 테스트 유형</p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>구문(문장) 커버리지 : 프로그램 내의 모든 명령문을 적어도 한 번 수행하는 커버리지</li>
<li>결정(선택, 분기) 커버리지 : 결정 포인트 내의 전체 조건식이 적어도 한번은 참과 거짓의 결과가 되도록 수행하는 커버리지</li>
<li>조건 커버리지 : 결정 포인트 내의 각 개별 조건식이 적어도 한번은 참과 거짓의 결과가 되도록 수행하는 커버리지</li>
<li>조건/결정 커버리지 : 전체 조건식 &amp; 개별 조건식 모두 참 한번, 거짓 한 번 결과가 되도록 수행하는 커버리지</li>
<li>변경 조건/결정 커버리지 : 개별 조건식이 다른 개별 조건식에 영향을 받지 않고 전체 조건식에 독립적으로 영향을 주도록 하는 커버리지</li>
<li>다중 조건 커버리지 : 결정 조건 내 모든 개별 조건식의 모든 가능한 조합을 100% 보장하는 커버리지</li>
<li>기본 경로 커버리지 : 수행 가능한 모든 경로를 테스트 하는 기법</li>
<li>제어 흐름 테스트 : 프로그램 제어 구조를 그래프 형태로 나타내어 내부 로직을 테스트하는 기법</li>
<li>데이터 흐름 테스트 : 제어 흐름 그래프에 사용현황 추가한 테스트 기법</li>
</ul>
<p data-ke-size="size14"><span style="color: #ee2323;">◆ 블랙박스 테스트(Black-Box Test): 사용자의 요구사항 명세를 보면서 수행하는 테스트 (기능 검사)</span></p>
<p data-ke-size="size14">◆ 블랙박스 테스트 유형</p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>동등 분할 테스트 : 입력 데이터의 영역을 유사한 도메인별로 유효값/무효값을 그룹핑하여 대푯값 테스트 케이스를 도출하여 테스트 하는 기법</li>
<li>경곗값 분석 테스트 : 입력 조건의 경계값을 테스트 케이스로 선정하여 검사하는 기법</li>
<li>결정 테이블 테스트 : 요구사항의 논리와 발생조건을 테이블 형태로 나열하여, 조건과 행위를 모두 조합해 테스트</li>
<li>상태 전이 테스트 : 이벤트에 의해 어느 한 상태에서 다른 상태로 전이 되는 경우의 수를 수행하는 테스트</li>
<li>유스케이스 테스트 : 유스케이스로 모델링 되어 있을 때 프로세스 흐름을 기반으로 테스트 케이스를 명세화해 수행하는 테스트</li>
<li>분류 트리 테스트 : SW의 일부 또는 전체를 트리구조로 분석 및 표현하여 테스트 케이스 설계하여 테스트</li>
<li>페어와이즈 테스트 : 테스트 데이터 값들 간에 최소한 한 번씩을 조합하는 방식</li>
<li>원인-결과 그래프 테스트 : 그래프를 활용해 입력 데이터 간의 관계 및 출력에 미치는 영향을 분석하여 효용성이 높은 케이스를 선정하여 테스트</li>
<li>비교 테스트 : 여러 버전의 프로그램에 같은 입력값을 넣어 동일한 데이터가 나오는지 비교하는 테스트</li>
</ul>
<p data-ke-size="size14">◆ 테스트 시각에 따른 분류</p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>검증(Verification): 소프트웨어 개발 과정을 테스트, 개발자 또는 시험자의 시각</li>
<li>확인(Validation): 소프트웨어 결과를 테스트, 사용자 시각</li>
</ul>
<p data-ke-size="size14"><span style="color: #ee2323;"><b><span>- 검증 : 소프트웨어 과정을 테스트 ( 개발자 관점 )</span></b></span></p>
<p data-ke-size="size14"><span style="color: #ee2323;"><b><span>- 확인 : 소프트웨어 결과를 테스트 ( 사용자 관점 )</span></b></span></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><b>1. 통합 테스트<span style="color: #ee2323;">(ex. 2021 02, 2021 03)</span> <br /><br />소프트웨어의 각 모듈 간의 인터페이스 관련 오류와 결함을 찾아내는 테스트 <br />- 하향식 통합 : 깊이-너비, 스텁 <br />- 상향식 통합 : 드라이버<br />- 빅뱅 통합 : 실제 모듈 테스트 진행</b>단위 테스트가 끝난 모듈을 통합하는 과정에서 발생하는 오류, 결함 찾는 테스트</p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14">(1) 비점진적 통합 방식</p>
<p data-ke-size="size14">- 모든 모듈이 미리 결합되어 있는 프로그램 전체를 테스트</p>
<p data-ke-size="size14">- 빅뱅 통합 테스트 방식</p>
<p data-ke-size="size14">- 소규모 소프트웨어에 유리, 단시간 내에 테스트 가능</p>
<p data-ke-size="size14">- 전체 프로그램 대상-&gt; 오류 발견 및 장애 위치 파악,수정 어려움</p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14">(2) 점진적 통합 방식</p>
<p data-ke-size="size14">- 모듈 단위로 단계적 통합하며 테스트.</p>
<p data-ke-size="size14">- 하향식, 상향식, 혼합식 통합 방식</p>
<p data-ke-size="size14">- 오류 수정 용이, 인터페이스와 연관된 오류를 완전히 테스트할 가능성 높다.</p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><b>2. 하향식 통합 테스트</b></p>
<p data-ke-size="size14">프로그램의 상위 모듈-&gt;하위모듈로 통합하면서 테스트</p>
<p data-ke-size="size14">- 주요 제어 모듈을 기준</p>
<p data-ke-size="size14">- 깊이 우선 통합법 or 넓이 우선 통합법</p>
<p data-ke-size="size14">- 테스트 초기부터 사용자에게 시스템 구조 보여줄 수 있음.</p>
<p data-ke-size="size14">- 상위 모듈에서는 테스트 케이스 사용 어려움</p>
<p data-ke-size="size14">- 절차</p>
<p data-ke-size="size14">   (1) 주요 제어 모듈은 작성된 프로그램을 사용. 주요 제어 모듈의 종속 모듈들은 스텁으로 대체</p>
<p data-ke-size="size14">      * 테스트 스텁: 제어 모듈이 호출하는 타 모듈의 기능을 수행하는 도구. 일시적 필요 조건만 가지고있는 시험용 모듈</p>
<p data-ke-size="size14">   (2) 깊이 우선 or 넓이 우선 등의 통합 방식에 따라 하위 모듈인 스텁들: 한번에 하나씩 실제모듈로 교체</p>
<p data-ke-size="size14">   (3) 모듈이 통합될때마다 테스트 실시</p>
<p data-ke-size="size14">   (4) 새로운 오류 발생않음을 보장하기 위해 회귀 테스트 실시</p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><b>3. 상향식 통합 테스트</b></p>
<p data-ke-size="size14">프로그램의 하위 모듈-&gt;상위 모듈로 통합하면서 테스트</p>
<p data-ke-size="size14">- 가장 하위 단계의 모듈부터 통합,테스트 수행-&gt; 스텁 필요 없음. 클러스터 필요함.</p>
<p data-ke-size="size14">  * 클러스터: 하나의 주요 제어 모듈과 관련된 종속 모듈의 그룹</p>
<p data-ke-size="size14">- 절차</p>
<p data-ke-size="size14">  (1) 하위 모듈들을 클러스터로 결합</p>
<p data-ke-size="size14">  (2) 상위 모듈에서 데이터 입,출력 확인 위해 드라이버 작성</p>
<p data-ke-size="size14">       * 드라이버: 테스트 대상의 하위모듈 호출. 파라미터 전달, 모듈 테스트 수행 후 결과 도출하는 도구</p>
<p data-ke-size="size14">  (3) 통합된 클러스터 단위로 테스트</p>
<p data-ke-size="size14">  (4) 테스트 완료시 클러스터는 프로그램 구조의 상위로 이동해 결합. 드라이버는 실제 모듈로 교체됨.</p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"># 테스트 드라이버와 스텁의 차이점</p>
<table style="border-collapse: collapse; width: 100%;" border="1" data-ke-align="alignLeft">
<tbody>
<tr>
<td>구분</td>
<td>드라이버</td>
<td>스텁</td>
</tr>
<tr>
<td>필요 시기</td>
<td><span>상위 모듈 없이 하위 모듈이 있는 경우 하위 모듈 구동</span></td>
<td>상위 모듈은 있지만 하위 모듈이 없는 경우 하위 모듈 대체</td>
</tr>
<tr>
<td>테스트 방식</td>
<td>상향식 테스트</td>
<td>하향식 테스트</td>
</tr>
<tr>
<td>공통점</td>
<td colspan="2">소프트웨어 개발과 테스트 병행시 이용함</td>
</tr>
<tr>
<td>차이점</td>
<td><span>-존재하는 하위 모듈과 없는 상위 모듈간의 인터페이스 </span><br /><span>- 소프트웨어 개발 완료시 드라이버든 본래 모듈로 교체됨</span></td>
<td><span>- 일시적으로 필요한 조건만 가지고 임시로 제공되는 가짜 모듈의 역할을 함.</span><br /><span>- 시험용 모듈임-&gt;드라이버보다 작성 쉬움</span></td>
</tr>
</tbody>
</table>
<p data-ke-size="size14"><span><b>52. 개발 단계에 따른 애플리케이션 테스트<span> </span><span><b><span><b><b><b>★</b></b></b></span></b></span><span><b><span><b><b><b>★</b></b></b></span></b></span><span><b><span><b><b><b>★</b></b></b></span></b></span></b></span></p>
<p data-ke-size="size14"><span>1. 개발 단계에 따른 애플리케이션 테스트</span></p>
<p data-ke-size="size14"><span>- 소프트웨어의 개발 단계에 따라 단위 테스트, 통합 테스트, 시스템 테스트, 인수 테스트로 분류된다. 이렇게 분류된 것을 테스트 레벨이라고 한다.</span></p>
<p data-ke-size="size14"><span>- 애플리케이션 테스트와 소프트웨어 개발 단계를 연결하여 표현한 것을 V-모델이라 한다.</span></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><span>2. 단위 테스트(Unit Test)</span></p>
<p data-ke-size="size14"><span>- 코딩 직후<span> </span><b>모듈이나 컴포넌트에 초점을 맞춰 테스트</b>하는 것이다.</span></p>
<p data-ke-size="size14"><span>- 인터페이스, 외부적 I/O, 자료 구조, 독립적 기초 경로, 오류 처리 경로, 경계 조건 등을 검사한다.</span></p>
<p data-ke-size="size14"><span>- 사용자의 요구사항을 기반으로 한<span> </span><b>기능성 테스트를 최우선으로 수행</b>한다.</span></p>
<p data-ke-size="size14"><span>- 구조 기반 테스트와 명세 기반 테스트로 나뉘지만<span> </span><b>주로 구조 기반 테스트를 시행</b>한다.</span></p>
<p data-ke-size="size14"><span>-<span> </span><b>구조 기반 테스트</b><span> </span>:<b><span> </span>프로그램 내부 구조 및 복잡도를 검증</b>하는<span> </span><b>화이트박스 테스트</b><span> </span>시행, 제어 흐름과 조건 결정 등이 목적이다.</span></p>
<p data-ke-size="size14"><span>-<span> </span><b>명세 기반 테스트</b><span> </span>:<b><span> </span>목적 및 실행 코드 기반</b>의<span> </span><b>블랙박스 테스트</b><span> </span>시행, 동등 분할, 경계 값 분석 등이 목적이다.</span></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><span>3. 통합 테스트(Integration Test)</span></p>
<p data-ke-size="size14"><span>- 통합 테스트는 단위 테스트가 완료된 모듈들을 결합하여 하나의 시스템으로 완성시키는 과정에서의 테스트를 의미한다.</span></p>
<p data-ke-size="size14"><span>- 모듈 간 또는 통합된 컴포넌트 간의 상호 작용 오류를 검사한다.</span></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><span>4. 시스템 테스트(System Test)</span></p>
<p data-ke-size="size14"><span>- 개발된 소프트웨어가 해당 컴퓨터 시스템에서 완벽하게 수행되는가를 점검하는 테스트이다.</span></p>
<p data-ke-size="size14"><span>- 환경적인 장애 리스크를 최소화하기 위해서는 실제 사용 환경과 유사하게 만든 테스트 환경에서 테스트를 수행해야 한다.</span></p>
<p data-ke-size="size14"><span>- 시스템 테스트는 기능적 요구사항과 비기능적 요구사항으로 구분하여 각각을 만족하는지 테스트한다.</span></p>
<p data-ke-size="size14"><span>- 기능적 요구사항 :명세서 기반의<span> </span><b>블랙박스테스트 시행</b></span></p>
<p data-ke-size="size14"><span>- 비기능적 요구사항 : 구조적 요소에 대한<b><span> </span>화이트박스테스트 시행</b></span></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><span>5. 인수 테스트(Acceptance Test)</span></p>
<p data-ke-size="size14"><span>- 소프트웨어가 사용자의<span> </span><b>요구사항을 충족하는지에 중점</b>을 두고 테스트하는 방법</span></p>
<p data-ke-size="size14"><span>-<span> </span><b>인수 테스트</b>는<span> </span><b>개발한 소프트웨어를 사용자가 직접 테스트</b>한다.</span><span></span></p>
<p data-ke-size="size14"><span>-<span> </span><b>알파 테스트</b><span> </span>:<span> </span><b>개발자의 장소에서 사용자가 개발자 앞에서 행하는 테스트 기법</b>이다, 통제된 환경에서 행해지며, 오류와 사용상의 문제점을 사용자와 개발자가 함께 확인하면서 기록한다.</span></p>
<p data-ke-size="size14"><span>-<span> </span><b>베타 테스트</b><span> </span>:<span> </span><b>선정된 최종 사용자가 여러 명의 사용자 앞에서 행하는 테스트 기법</b>이다, 개발자에 의해 제어되지 않은 상태에서 테스트가 행해지며, 발견된 오류와 사용상의 문제점을 기록하고 개발자에게 주기적으로 보고한다.</span></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><span>핵심</span></p>
<p data-ke-size="size14"><span>- 단위 테스트 -&gt; 통합 테스트 -&gt; 시스템 테스트 -&gt; 인수 테스트</span></p>
<p data-ke-size="size14"><span>- 알파 테스트는 선택된 사용자가 개발자 앞에서 검사, 베타 테스트는 선정된 최종 사용자가 여러 명의 사용자 앞에서 검사</span></p>
<p data-ke-size="size14"><span>- 알파 테스트는 통제된 환경에서, 베타 테스트는 개발자에 의해 제어되지 않은 상태에서 검사한다.</span></p>
<p data-ke-size="size14"><b><span><br /><br />* 테스트 시나리오 : 테스트를 수행하기 위한 테스트 케이스의 집합으로 테스트 케이스의 실행 순서와 절차를 작성한 문서 <br /><br /><b><span>6) 테스트 자동화 도구(단답형)</span></b></span></b></p>
<p data-ke-size="size14"><span>테스트 도구를 활용하여<span style="color: #ee2323;"><b><span> </span>반복적인 테스트를 스크립트 형태로 구현</b></span>하여 시간 단축과 비용 최소화</span></p>
<p data-ke-size="size14"><b><span>* 정적 분석 도구(2020 실기 2회 기출문제) :<span style="color: #ee2323;"><span> </span>애플리케이션을 실행하지 않고 테스트 수행</span></span></b></p>
<p data-ke-size="size14"><span>- 애플리케이션을 실행하지 않고 소스코드에 대한 표준 코딩, 코딩 스타일, 코드 복잡도 및 결함을 발견하기 위해 사용</span><span></span><b><span><br /></span></b></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><b><span>8) 애플리케이션 성능 측정 지표<span style="color: #ee2323;">( 2020 실기 1회 기출문제 )</span></span></b></p>
<p data-ke-size="size14"><b><span>* 처리량(Throughput)</span></b></p>
<p data-ke-size="size14"><span>- 일정 시간 내 애플리케이션이<b><span> </span>처리하는 작업의 양</b></span></p>
<p data-ke-size="size14"><span>- 애플리케이션이 주어닌 시간에 처리할 수 있는 트랜잭션 수</span></p>
<p id="SE-6c75c151-f246-4d98-b2e8-2634d54e5c6a" data-ke-size="size14"><b><span>* 응답시간(Response Time)</span></b></p>
<p data-ke-size="size14"><span>- 애플리케이션에 작업을<span> </span><b>요청해서 응답 도착까지</b><span> </span>걸린 시간</span></p>
<p data-ke-size="size14"><span>- 응답 후 입력에 대한 응답 출력<b>(완료된 상태)</b></span></p>
<p id="SE-787acccf-16c3-4f0f-9a97-bc1413893462" data-ke-size="size14"><b><span>* 경과시간(Turn Around Time)</span></b></p>
<p data-ke-size="size14"><span>- 애플리케이션에 작업을<span> </span><b>의뢰한 시간부터 처리가 완료될 때까지</b><span> </span>걸린 시간</span></p>
<p data-ke-size="size14"><span>- 요구를 입력하여 트랜잭션 처리 후 출력<b>(완료가 되지 않은 상태)</b></span></p>
<p id="SE-bcd4e894-0aae-46e0-8ad7-f79e330ac570" data-ke-size="size14"><b><span>* 자원사용률(단답형)</span></b></p>
<p data-ke-size="size14"><span>- 애플리케이션이 작업을 처리할 동안의 CPU, MEM, DISK 등의 사용량</span></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><span></span>◆ 운영체제(OS: Operating System): 사용자가 컴퓨터의 하드웨어를 쉽게 사용할 수 있도록 인터페이스를 제공해주는 소프트웨어</p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14">운영체제의 목적<span style="color: #ee2323;">(ex. 2020 01)</span>  <br />처리량 일정 시간 내에 시스템이 처리하는 일의 양 <br />반환 시간 시스템에 작업을 의뢰한 시간부터 처리가 완료될 때까지 걸린 시간 <br />가용성 시스템을 사용할 필요가 있을때 즉시 사용 가능한 정도 <br />신뢰도 주어진 문제를 정확이 해결하는 정도 <br />MacOS : 1980년대 애플 사가 UNIX를 기반으로 개발한 운영체제이다. <br /><br />UNIX<span style="color: #ee2323;">(ex. 2020 04)</span> <br />데니스 리치와 켄톰슨 등이 함께 벨 연구소를 통해 만든 운영체제이며, 90% 이상 C언어로 구현되어 있고,  <br />시스템 프로그램이 모듈화되어 있어서 다른 하드웨어 기종으로 쉽게 이식 가능하며 계층적 트리 구조를 가짐으로써 통합적인 파일 관리가 용이한 운영체제 <br /><br />UNIX 시스템의 구성 <br />커널(Kernel) : UNIX에 가장 핵심적인 부분. 프로그램과 하드웨어간의 인터페이스 등 여러가지 일 담당. <br />쉘(Shell) : 사용자의 명령어를 인삭하여 프로그램을 호출하고 명령을 수행하는 명령어 해석기.</p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14">◆ 운영체제 종류: 윈도즈(Windows), 유닉스(Unix), 리눅스(Linux), 맥(Mac), 안드로이드(Android)</p>
<p data-ke-size="size14">◆ 메모리 관리 기법</p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>반입 기법: 메모리 적재 시기 결정(When)</li>
<li>배치 기법: 메모리 적재 위치 결정(Where)</li>
<li>할당 기법: 메모리 적재 방법 결정(How)</li>
<li>교체 기법: 메모리 교체 대상 결정(Who)</li>
</ul>
<p data-ke-size="size14">◆ 메모리 배치 기법</p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>최초 적합(First-fit): 프로세스가 적재될 수 있는 가용 공간 중에서 첫 번째 분할에 할당하는 방식</li>
<li>최적 적합(Best fit): 가용 공간 중에서 가장 크기가 비슷한 공간을 선택하여 프로세스를 적재하는 방식</li>
<li>최악 접합(Worst-fit): 프로세스의 가용 공간들 중에서 가장 큰 공간에 할당하는 방식</li>
</ul>
<p data-ke-size="size14">◆ 프로세스 상태</p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>생성(Create) 상태: 사용자에 의해 프로세스가 생성된 상태</li>
<li>준비(Ready) 상태: CPU를 할당받을 수 있는 상태</li>
<li>실행(Running) 상태: 프로세스가 CPU를 할당받아 동작 중인 상태</li>
<li>대기(Waiting) 상태: 프로세스 실행 중 입출력 처리 등으로 인해 CPU를 양도하고 입출력 처리가 완료까지 대기 리스트에서 기다리는 상태</li>
<li>완료(Complete) 상태: 프로세스가 CPU를 할당받아 주어진 시간 내에 완전히 수행을 종료한 상태</li>
</ul>
<p data-ke-size="size14">◆ 프로세스 상태 전이</p>
<p>[##_Image|kage@w1va9/btrBsFFoI9B/pjBVhSs68jjUy8FUfOVbVK/img.png|CDM|1.3|{"originWidth":1366,"originHeight":511,"style":"alignCenter"}_##]</p>
<p data-ke-size="size14">◆ 프로세스 스케줄링의 유형</p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>선점형 스케줄링: 우선순위가 높은 프로세스가 CPU를 점유하는 스케줄링
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>라운드 로빈(Round Robbin): 프로세스는 같은 크기의 CPU 시간 할당</li>
<li>SRT(Shortest Remaining Time First): 가장 짧은 시간이 소요되는 프로세스를 먼저 수행</li>
<li>다단계 큐(Multi Level Queue): 여러 개의 큐를 이용하여 상위단계 작업에 의한 하위단계 작업이 선점</li>
<li>다단계 피드백 큐(Multi Level Feedback Queue): 큐마다 서로 다른 CPU시간 할당량을 부여, FIFO+라운드 로빈 스케줄링 기법 혼합</li>
</ul>
</li>
<li>비선점형 스케줄링: 한 프로세스가 CPU를 할당 받으면 작업 종료 전까지 다른 프로세스는 CPU점유 불가능한 스케줄링
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>우선순위(Priority): 프로세스별 우선순위에 따라 CPU 할당</li>
<li>기한부(Deadline): 작업들이 명시된 기한 내에 완료되도록 계획</li>
<li>FCFS(First Come First Service): 프로세스가 대기 큐에 도착한 순서에 따라 CPU할당=FIFO</li>
<li>SJF(Shortest Job First): 가장 짧은 작업부터 수행, 평균 대시 시간 최소화. 기아현상 발생</li>
<li>HRN(Highest Response Ratio Next): 대기 중인 프로세스 중 현재 응답률이 가장 높은 것을 선택, 기아현상 최소화 기법</li>
</ul>
</li>
<li> </li>
</ul>
<p data-ke-size="size14"><span><span><b>1) 프로세스 스케줄링 : CPU를 사용하려는 프로세스 사이의 우선순위를 관리하는 작업</b></span></span></p>
<p data-ke-size="size14"><span><span>- 프로세스 스케줄링 이용 시 CPU 이용률 증가, 오버헤드 응답시간, 반환시간, 대기시간 감소</span></span></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><span><span>* 서비스 시간 : 프로세스가 결과를 산출하기 전까지 소요되는 시간</span></span></p>
<p data-ke-size="size14"><span><span>* 응답 시간 : Response Time으로 대기시간 + 수행시간</span></span></p>
<p data-ke-size="size14"><span><span>* 대기 시간 : 프로세스가 할당되기 전까지 대기 큐에서 대기하는 시간</span></span></p>
<p data-ke-size="size14"><span><span>* 응답률 :</span></span><span><span><b><span> </span>(서비스 시간 + 대기시간) / 서비스 시간 -&gt; HRN(Highest Response Ratio Next) <span style="color: #ee2323;">(2020 실기 1회 기출)</span></b></span></span></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14">◆ 네트워크(Network): 원하는 정보를 원하는 수신자 또는 기기에 정확하게 전송하기 위한 기반 인프라</p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>광대역 네트워크(WAN): LAN에 비해 전송거리가 넓음</li>
<li>근거리 네트워크(LAN): 한 건물 또는 작은 지역 커버</li>
</ul>
<p data-ke-size="size14">◆ <span style="color: #ee2323;">프로토콜(Protocol)</span>: 서로 다른 시스템이나 기기들 간의 데이터 교환을 원활히 하기 위한 표준화된 통신규약</p>
<p data-ke-size="size14">◆ <span style="color: #ee2323;">프로토콜 기본 3요소</span></p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>구문(Syntax): 시스템 간의 정보 전송을 위한 데이터 형식, 코딩, 신호 레벨 등의 규적</li>
<li>의미(Semantic): 시스템 간의 정보 전송을 위한 제어 정보로 조정과 에러 처리를 위한 규정</li>
<li>타이밍(Timing): 시스템 간의 정보 전송을 위한 속도 조절과 순서 관리 규정</li>
</ul>
<p data-ke-size="size14">◆ 네트워크 프로토콜(Network Protocol): 컴퓨터나 원거리 통신 장비 사이에서 메시지를 고받는 양식과 규칙의 체계</p>
<p data-ke-size="size14">◆ 데이터 링크 계층 프로토콜</p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>HDLC(High-level Data Link Control): 점대점 방식이나 다중방식 통신에 사용되며, 동기식 비트 중심</li>
<li>PPP(Point-to-Point Protocol): 네트워크 분야에서 두 통신 노드 간의 직접적인 연결</li>
<li>프레임 릴레이(Frame Relay): 프로토콜 처리를 간략화하여 데이터 처리속도의 향상 및 전송 지연을 감소시킨 고속데이터 전송 기술</li>
<li>ATM(Asynchronous Transport Mode): 53바이트 셀 단위로 전달하는 비동기식 시분할 다중화 방식의 패킷형 전송 기술</li>
</ul>
<p data-ke-size="size14">◆ <span style="color: #ee2323;">네트워크 계층 프로토콜</span></p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>IP(Internet Protocol): 송수신 간의 패킷 단위로 데이터를 교환하는 네트워크에서 정보를 주고받는 데 사용</li>
<li>ARP(Adress Resolution Protocol): IP네트워크상에서 IP주소를 MAC주소(물리주소)로 변환하는 프로토콜</li>
<li>RARP(Reverse Address Resolution Protocol): 서버로부터 IP 주소를 요청하기위해 사용하는 프로토콜</li>
<li>ICMP(Internet Control Message Protocol): IP 패킷을 처리할 때 발생되는 문제를 알려주는 프로토콜</li>
<li>IGMP(Internet Group Managemnet Protocol): 호스트 컴퓨터와 인접 라우터가 멀티캐스트 그룹 멤버십을 구성하는 데 사용하는 통신 프로토콜</li>
<li>라우팅 프로토콜(Routing Protocol): 데이터 전송을 위해 최적의 경로를 설정해주는 라우터 간의 상호 통신 프로토콜</li>
</ul>
<p data-ke-size="size14">◆ <span style="color: #ee2323;">IPv4 (Internet Protocol version 4):</span> 인터넷에서 사용되는 패킷 교환 네트워크상에서 데이터를 교환하기 위한 32비트 주소체계를 갖는 네트워크 계층 프로토콜</p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>8비트씩 4부분으로 나뉜 10진수</li>
<li>0~255까지 3자리수 표현</li>
<li>유니캐스트, 멀티캐스트, 브로드캐스트</li>
</ul>
<p data-ke-size="size14">◆ IPv4 클래스 분류</p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>A클래스: 국가나 대형 통신망에 사용(1~127), 네트워크 사용자에게 부여가 가능한 IP</li>
<li>B클래스: 중대형 통신망에 사용(128~191)</li>
<li>C클래스: 소규모 통신망에 사용(192~223)</li>
<li>D클래스: 멀티캐스트 용도로 예약된 주소(224~239)</li>
<li>E클래스: 연구를 위해 예약된 주소(공용 사용 불가)</li>
</ul>
<p data-ke-size="size14">◆ <span style="color: #ee2323;">IPv6 (Internet Protocol version 6):</span> IPv4의 주소 부족 문제를 해결하기 위해 개발</p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>IPv4에 비해 자료 전송속도가 빠름</li>
<li>128비트 주소체계</li>
<li>16비트씩 8개 부분으로 나눈 16진수</li>
<li>유니캐스트, 멀티캐스트, 애니캐스트</li>
</ul>
<p data-ke-size="size14">◆ IPv4에서 IPv6으로 전환 방법: 듀얼 스택, 터널링, 주소 변환 방식</p>
<p data-ke-size="size14">◆ 라우팅 프로토콜</p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>내부 라우팅 프로토콜(IGP)
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>RIP(Routing Information Protocol): AS(자율시스템)내에서 사용하는 거리 벡터 알고리즘에 기초하여 개발된 내부 라우팅 프로토콜</li>
<li>OSPF(Oepn Shortest Path First): 자신을 기준으로 링크 상태 알고리즘을 적용하여 최단 경로를 찾는 라우팅 프로토콜</li>
</ul>
</li>
<li>외부 라우팅 프로토콜(EGP)
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>BGP(Border Gateway Protocol): AS상호 간에 경로 정보를 교환하기 위한 라우팅 프로토콜</li>
</ul>
</li>
</ul>
<p data-ke-size="size14">◆ TCP(Transmission Control Protocol):</p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>TCP 특징: 신뢰성 보장, 연결 지향적 특징, 흐름 제어, 혼잡 제어</li>
</ul>
<p data-ke-size="size14">◆ UDP(User Datagram Protocol):</p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>UDP 특징: 비신뢰성, 순서화되지 않은 데이터그램 서비스 제공, 실시간 응용 및 멀티캐스트 가능, 단순 헤어</li>
</ul>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li> </li>
</ul>
<p data-ke-size="size14">◆ <span style="color: #ee2323;">애드 혹 네트워크(Ad-hoc Network):</span> 노드들에 의해 자율적으로 구성되는 기반 구조가 없는 네트워크</p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14">네트워크 구축 <br />네트워크(Network): 두 대 이상의 컴퓨터를 연결하여 자원을 공유하는 것</p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14">성형(Star; 중앙 집중형)<br />중앙에 중앙 컴퓨터, 이를 중심으로 단말장치 연결 <br />P2P 방식으로 회선 연결 <br />중앙 컴퓨터 고장나면 전체 통신망 기능 정지</p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14">링형(Ring; 루프형) <br />컴퓨터와 단말장치들을 서로 이웃하는 것끼리 연결시킨 P2P 연결 방식 <br />단말장치 추가/제거, 기밀보호 어려움 <br />각 단말장치 전송 지연 발생 가능 <br />데이터 단방향, 양방향 전송 가능</p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14">버스형(Bus)<br />한 개의 통신 회선에 여러 대의 단말장치 연결 <br />단말장치 추가/제거 용이 <br />단말장치 고장나도 영향을 주지 않으므로 신뢰성 증가 <br />기밀 보장 어려움 <br />통신 회선 길이 제한</p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14">계층형(Tree; 분산형) <br />중앙 컴퓨터와 일정 지역 단말장치까지는 하나의 통신 회선 연결, 이웃 단말장치는 일정 지역 내에 설치된 중간 단말 장치로 연결</p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14">망형(Mesh) <br />모든 지점의 컴퓨터와 단말장치를 서로 연결 <br />통신 회선 총 경로가 가장 긺 <br />노드 수 n일 때, 회선은 n(n - 1) / 2개, 노드당 포트 (n - 1)개 필요</p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14">WAN(Wide Area Network): 먼 거리, 속도 느림, 에러 높음, 일정 지역을 LAN으로 연결 후 각 LAN을 연결하는 방식</p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14">NAT(Network Address Translation; 네트워크 주소 변환)<span style="color: #ee2323;">(ex. 2020 04)</span> <br />한 개의 정식 IP 주소에 대량의 가상 사설 IP 주소 할당 및 연결 <br />광대역 네트워크(WAN): LAN에 비해 전송거리가 넓음 <br />근거리 네트워크(LAN): 한 건물 또는 작은 지역 커버</p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><a href="https://tkdals1049.tistory.com/24">12장 제품 소프트웨어 패키징</a></p>
<p data-ke-size="size14"><span><span><b>1) 제품 소프트웨어 패키징</b></span></span></p>
<p data-ke-size="size14"><span><span>- 개발이 완료된 소프트웨어를 고객에게 전달하기 위해 패키징 하는 과정</span></span></p>
<p data-ke-size="size14"><span><span>- 키워드 : 버전관리/릴리즈 노트, 고객 중심, 모듈화</span></span></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><span><span><b>* 모듈</b></span></span></p>
<p data-ke-size="size14"><span><span>- 소프트웨어 설계에서 기능 단위로 분해하고 추상되어<span> </span></span></span><span><span><b>재사용 및 공유가 가능</b></span></span><span><span>한 단위</span></span></p>
<p data-ke-size="size14"><span><span><b>* <span style="color: #ee2323;">모듈화(서술형)</span></b></span></span></p>
<p data-ke-size="size14"><span><span>- 모듈을 통해 제품 소프트웨어의 성능을 향상시키고 시스템의 통합, 시험 디버깅 및 수정을 용이하게 하는 소프트웨어 설계 기법</span></span></p>
<p data-ke-size="size14"><span><b>* 사용자 중심의 모듈 패키징 프로세스</b></span></p>
<p data-ke-size="size14"><span>- 기능 식별 &gt; 모듈화 &gt; 빌드 진행 &gt; 사용자 환경 분석 &gt; 패키징 적용 시험 &gt; 패키징 변경 개선</span></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><span><b>2) 릴리즈 노트</b></span></p>
<p data-ke-size="size14"><span><b>- 최종 사용자인 고객에게 잘 정리된 릴리즈 정보를 제공하는 문서, 현재 시제로 작성</b></span></p>
<p data-ke-size="size14"><span>- 정보 제공 : 릴리즈 노트에는 테스트 결과와 정보 포함</span></p>
<p data-ke-size="size14"><span>- 관리의 용이성 : 자동화, 릴리즈 정보를 체계적으로 관리</span></p>
<p data-ke-size="size14"><span>- 고려 사항 : 개발팀에서 작성, 명확, 정확, 완전한 정보 제공</span></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><span><b>* 구성 요소 <span style="color: #ee2323;">(2020 실기 1회 기출)</span></b></span></p>
<p data-ke-size="size14"><span><b>- 헤더 : 문서 이름, 제품 이름, 버전 번호, 릴리즈 날짜</b></span></p>
<p data-ke-size="size14"><span><b>- 개요 : 제품 및 번경에 대한 간략한 전반적인 개요</b></span></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><span><b>* 릴리즈 노트 작성 프로세스(모정개 영정추)</b></span></p>
<p data-ke-size="size14"><span><b>- 모듈 식별 &gt; 릴리즈 정보 확인 &gt; 릴리즈 노트 개요 작성 &gt; 영향도 체크 &gt; 정식 릴리즈 노트 작성 &gt; 추가 개선 항목 식별</b></span></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><span><b>3) 제품 소프트웨어 패키징 도구</b></span></p>
<p data-ke-size="size14"><span>패키징 시 디지털 콘텐츠의<span> </span></span><span><b>지식 재산권을 보호</b></span><span>하고 관리하는 기능 제공, 안전한 유통 배포 보장하는 도구</span></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><span><b>4) 저작권 보호 패키징 도구</b></span></p>
<p data-ke-size="size14"><span><b>* DRM(디지털 저작권 관리) (단답형)</b></span></p>
<p data-ke-size="size14"><span>- 데이터의 안전한 배포를 활성화하거나 불법 배포를 방지하여 인터넷이나 기타 디지털 매체를 통해 유통되는 데이터의 저작권을 보호하기 위한 시스템</span></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><span><b>5) 암호화</b></span></p>
<p data-ke-size="size14"><span>텍스트, 콘텐츠 등을 암호문으로 만드는 기술</span></p>
<p data-ke-size="size14"><span>* 공개키 기반 구조(PKI), 대칭 및 비대칭 암호화 전자서명, 키 관리, 식별 기술, 저작권 표현, 암호화 파일 생성, 정책 관리, 크랙 방시, 인증</span></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><span><b>* 공개키 기반 구조(PKI)</b></span></p>
<p data-ke-size="size14"><span>- 공개키 암호화 방식 기반으로 디지털 인증서를 활용하는 소프트웨어, 하드웨어, 사용자 등을 총칭하는 암호 기술</span></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><span><b>* 대칭 및 비대칭 암호화</b></span><span><span> </span>: 암호화 시 키, 복호화 키 생성</span></p>
<p data-ke-size="size14"><span>* 전자 서명 : 전자적 형태의 정보</span></p>
<p data-ke-size="size14"><a href="https://ss-o.tistory.com/103"><span>[정보처리기사 실기/실기 정리] - 정보처리기사 실기) 9장 소프트웨어 개발 보안 구축</span></a></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><span><b>* DOI(Digital Object Identifier) (단답형)</b></span></p>
<p data-ke-size="size14"><span>- 디지털 저작물에 특정 번호를 부여하는 일종의<span> </span></span><span><b>바코드 시스템</b></span></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><span><b>* URI (단답형)</b></span></p>
<p data-ke-size="size14"><span>- 인터넷에 있는 자원을 나타내는<span> </span></span><span><b>유일한 주소</b></span></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><span><b>* XrML (단답형)</b></span></p>
<p data-ke-size="size14"><span>- 디지털 콘텐츠, 웹 서비스 권리 조건을 표현한 XML 기반의 마크업 언어</span></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><span><b>* MPEG-21 (단답형)</b></span></p>
<p data-ke-size="size14"><span>- 멀티미디어 표준 규격</span></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><span><b>* <span style="color: #ee2323;">XML (단답형)</span></b></span></p>
<p data-ke-size="size14"><span><s>-<span> </span></s></span><span><s><b>마크업 언어로 '키'와 '값'의 한 쌍</b></s></span><span><s>으로 사람이 쉽게 알아볼 수 있는 오브젝트를 생성하는 언어</s></span></p>
<p data-ke-size="size14"> <br /><span><b>*<span style="color: #ee2323;"> JSON (단답형)</span></b></span><br /><span><b>비동기 브라우저 / 서버 통신(AJAX)을 위해 &ldquo;속성-값 쌍&rsquo;, &lsquo;키-값 쌍&rsquo;으로 이루어진 데이터 오브젝트를 전달하기 위해 인간이 읽을 수 있는 텍스트를 사용하는 개방형 표준 포맷</b></span><br /><br /></p>
<p data-ke-size="size14"><span><b>* 코드 난독화 (단답형)</b></span></p>
<p data-ke-size="size14"><span>-<span> </span></span><span><b>역공학을 통한 공격을 막기 위해 프로그램 소스를 알아보기 힘든 코드로 바꾸는 기술</b></span></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><span><b>* Secure DB (단답형)</b></span></p>
<p data-ke-size="size14"><span>- 커널 암호화 방식으로 데이터베이스 파일을 직접 암호화하고 접근제어와 보안적인 요소가 추가된 데이터베이스 강화 기술</span></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><span><b>* SSO(Single Sign On) (단답형)</b></span></p>
<p data-ke-size="size14"><span>- 한 번의 인증 절차를 통해 여러 정보 시스템에<span> </span></span><span><b>재인증 절차없이 사용</b></span><span>할 수 있는 통합 로그인 기술</span></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><span><b>* CMS (단답형)</b></span></p>
<p data-ke-size="size14"><span>- 콘텐츠 생산 전 활동의 과정을 관리하는 기</span></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><span><b>7) 제품 소프트웨어 패키징의 형상 관리</b></span></p>
<p data-ke-size="size14"><span><b>* 형상관리<span style="color: #ee2323;">(2020 실기 2회 기출)</span></b></span></p>
<p data-ke-size="size14"><span>- 소프트웨어의 변경사항을 계속적으로 추적하고 버전 관리 및 통제하는 관리 기법</span></p>
<p data-ke-size="size14"><span><b>- </b></span><span style="color: #ee2323;"><span><b>소프트웨어의 변경 사항을 관리하기 위해 개발된 일련의 활동</b></span></span></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><span><b>* 형상관리 도구의 기능</b></span><span><b> : 체크인, 체크아웃, 커밋</b></span></p>
<p data-ke-size="size14"><span><b>- 체크인</b></span></p>
<p data-ke-size="size14"><span>: 개발자가 수정한 소스를 형상관리 저장소로 업로드하는 기능</span></p>
<p data-ke-size="size14"><span><b>- 커밋</b></span></p>
<p data-ke-size="size14"><span>: 개발자가 소스를 형상관리 저장소에 업로드 후 최종적으로 업데이트가 되었을 때 형상관리 서버에 반영하도록 하는 기능</span></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><span><b>* 형상관리 역할 : 관리 유용, 동시 개발, 빠른 복구</b></span></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><span><b>* 형상 식별</b></span></p>
<p data-ke-size="size14"><span>- 형상 관리 대상에 이름과 관리 번호를 부여하고, </span><span><b>계층(Tree) 구조로 구분</b></span><span>하여 수정 및 추적이 용이하도록 하는 작업</span></p>
<p data-ke-size="size14"><span><b>* 버전 제어</b></span></p>
<p data-ke-size="size14"><span>- 소프트웨어 업그레이드나 유지 보수 과정에서 생성된</span><span><b> 다른 버전의 형상 항목을 관리</b></span><span>하고, 이를 위해 </span><span><b>특정 절차와 도구(Tool)를 결합</b></span><span>시키는 작업</span></p>
<p data-ke-size="size14"><span><b>* 형상 통제(변경 관리)</b></span></p>
<p data-ke-size="size14"><span>- 식별된 형상 항목에 대한 변경 요구를 검토하여 </span><span><b>현재의 기준선(Base Line)</b></span><span>이 잘 반영될 수 있도록 조정하는 작업</span></p>
<p data-ke-size="size14"><span><b>* 형상 감사</b></span></p>
<p data-ke-size="size14"><span>- 기준선의 무결성을 평가하기 위해</span><span><b> 확인, 검증, 검열 과정을 통해 공식적으로 승인</b></span><span>하는 작업</span></p>
<p data-ke-size="size14"><span><b>* 형상 기록(상태 보고)</b></span></p>
<p data-ke-size="size14"><span>- 형상의 식별, 통제, 감사 작업의 결과를 기록, 관리하고 보고서를 작성하는 작업</span></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><span><b>* 공유 폴더 방식</b></span></p>
<p data-ke-size="size14"><span>- 버전 관리 자료가 로컬 컴퓨터의 </span><span style="color: #ee2323;"><span><b>공유 폴더에 저장</b></span></span><span>되어 관리되는 방식</span></p>
<p data-ke-size="size14"><span>- 파일의 변경 사항을 데이터베이스에 기록하여 관리</span></p>
<p data-ke-size="size14"><span>- 종류 : SCCS, RCS, PVCS, QVCS 등</span></p>
<p data-ke-size="size14"><span><b>* RCS</b></span></p>
<p data-ke-size="size14"><span>- 파일, 잠금 방식으로 소스파일 수정은 한 명으로 제한하여 버전 관리</span></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><span><b>* 클라이언트/서버 방식</b></span></p>
<p data-ke-size="size14"><span>- 버전 관리 자료가</span><span style="color: #ee2323;"><span><b> 중앙 시스템(서버)에 저장</b></span></span><span>되어 관리되는 방식</span></p>
<p data-ke-size="size14"><span>- 모든 버전 관리는 서버에서 수행</span></p>
<p data-ke-size="size14"><span>- 서버에 문제가 생기면, 서버가 복구되기 전가지 다른 개발자와의 협업 및 버전 관리 작업은 중단</span></p>
<p data-ke-size="size14"><span>- 종류 : CVS, SVN(Subversion), CVSNT, Clear Case, CMVC, Perforce 등</span></p>
<p data-ke-size="size14"><span>* CVS</span></p>
<p data-ke-size="size14"><span>- 서버와 클라이언트를 구성되어 다수의 인원이 동시에 접근 가능하여 버전 관리 가능</span></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><span style="color: #ee2323;"><span><b>* Subversion(서브버전, SVN)</b></span></span></p>
<p data-ke-size="size14"><span><b>- CVS를 개선한 것</b></span><span>, 아파치 소프트웨어 재단에서 발표</span></p>
<p data-ke-size="size14"><span>- 모든 개발 작업은</span><span style="color: #ee2323;"><span><b> trunk 디렉터리</b></span></span><span>에서 수행</span></p>
<p data-ke-size="size14"><span>-</span><span><b> commit 할 때마다 revision이 1씩 증가 ( 커밋 실패 시 롤백 지원 가능 )</b></span></p>
<p data-ke-size="size14"><span>- 클라이언트는 대부분의 운영체제에서 사용되지만, 서버는 주로 유닉스를 사용</span></p>
<p data-ke-size="size14"><span><b>- 디렉토리 파일을 자유롭게 이동 가능</b></span></p>
<p data-ke-size="size14"><span>- add, commit, update, checkout, lock/unlock, import, export, info, diff, merge</span></p>
<p data-ke-size="size14"><span>​</span></p>
<p data-ke-size="size14"><span><b>* 분산 저장소 방식</b></span></p>
<p data-ke-size="size14"><span>- 버전 관리 자료가 하나의 </span><span style="color: #ee2323;"><span><b>원격 저장소</b></span></span><span style="color: #ee2323;"><span>와 분산된 개발자 PC의</span></span><span style="color: #ee2323;"><span><b> 로컬 저장소</b></span></span><span style="color: #ee2323;"><span>에 함께 저장</span></span><span>되어 관리되는 방식</span></p>
<p data-ke-size="size14"><span>- 로컬 저장소에서 버전 관리가 가능하므로 원격 저장소에 문제가 생겨도 로컬 저장소의 자료를 이용하여 작업 가능</span></p>
<p data-ke-size="size14"><span>- 종류 : Git, GNU arch, DCVS, Bazaar, Bitkeeper 등</span></p>
<p data-ke-size="size14"><span>* Bitkeeper</span></p>
<p data-ke-size="size14"><span>- SVN과 비슷한 중앙 통제 방식으로 대규모 프로젝트에서 빠른 속도</span></p>
<p data-ke-size="size14"> </p>
<p data-ke-size="size14"><span style="color: #ee2323;"><span><b>* Git(깃)</b></span></span></p>
<p data-ke-size="size14"><span>- 지역 저장소는 개발자들이 실제 개발을 진행하는 장소, 버전 관리가 수행</span></p>
<p data-ke-size="size14"><span>- 원격 저장소는 여러 사람들이 협업을 위해 버전을 공동으로 관리하는 곳</span></p>
<p data-ke-size="size14"><span>- </span><span style="color: #ee2323;"><span><b>branch를 이용</b></span></span><span>하면 기본 버전 관리 틀에 영향을 주지 않으면서 다양한 형태의 기능 테스팅이 가능</span></p>
<p data-ke-size="size14"><span>- 파일의 변화를 스냅샷으로 저장</span></p>
<p data-ke-size="size14"><span>- </span><span><b>SVN 저장소에 대한 이관 기능</b></span></p>
<p data-ke-size="size14"><span>- add, commit, branch, checkout, merge, init, remote add, push, fetch, clone, fork</span></p>
<p data-ke-size="size14"><span><b>- branch, check-out, commit 등 로컬 환경에서의 형상관리 기능</b></span></p>
<p data-ke-size="size14"><span><b>- push, fetch, pull 등 원격 환경에서의 변경 전송 기능</b></span></p>
<figure id="og_1651835501297" contenteditable="false" data-ke-type="opengraph" data-ke-align="alignCenter" data-og-type="article" data-og-title="정처기 실기 12장 제품 소프트웨어 패키징" data-og-description="1. 제품 소프트웨어 패키징 1) 제품 소프트웨어 패키징 - 개발이 완료된 소프트웨어를 고객에게 전달하기 위해 패키징 하는 과정 - 키워드 : 버전관리/릴리즈 노트, 고객 중심, 모듈화 * 모듈 - 소" data-og-host="tkdals1049.tistory.com" data-og-source-url="https://tkdals1049.tistory.com/24" data-og-url="https://tkdals1049.tistory.com/24" data-og-image="https://scrap.kakaocdn.net/dn/c2TERF/hyOjaE7SEN/CZLMxGF4TCjRKQaK8c6Mj1/img.png?width=800&amp;height=800&amp;face=0_0_800_800,https://scrap.kakaocdn.net/dn/tk9JY/hyOhD3fbE6/Lqoocubf3S9NGm2Bq4knfk/img.png?width=800&amp;height=800&amp;face=0_0_800_800,https://scrap.kakaocdn.net/dn/iaz6e/hyOhEA58lo/X962DjkWpTv5aqNNlTRow0/img.png?width=750&amp;height=280&amp;face=0_0_750_280"></figure>
<p data-ke-size="size14"> </p>